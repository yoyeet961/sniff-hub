-- Gui to Lua
-- Version: 3.2

-- Instances:

local SniffHub = Instance.new("ScreenGui")
local OpenClose = Instance.new("TextButton")
local GUIFrame = Instance.new("Frame")
local Page1 = Instance.new("Frame")
local UIGradient = Instance.new("UIGradient")
local ServerAdmin = Instance.new("TextButton")
local TextButton_Roundify_12px = Instance.new("ImageLabel")
local UIGradient_2 = Instance.new("UIGradient")
local Joy = Instance.new("TextButton")
local TextButton_Roundify_12px_2 = Instance.new("ImageLabel")
local UIGradient_3 = Instance.new("UIGradient")
local MemeAnimations = Instance.new("TextButton")
local TextButton_Roundify_12px_3 = Instance.new("ImageLabel")
local UIGradient_4 = Instance.new("UIGradient")
local Page2Button = Instance.new("TextButton")
local TextButton_Roundify_12px_4 = Instance.new("ImageLabel")
local UIGradient_5 = Instance.new("UIGradient")
local TextLabel = Instance.new("TextLabel")
local Page2 = Instance.new("Frame")
local UIGradient_6 = Instance.new("UIGradient")
local Title = Instance.new("TextLabel")
local GravityGun = Instance.new("TextButton")
local TextButton_Roundify_12px_5 = Instance.new("ImageLabel")
local UIGradient_7 = Instance.new("UIGradient")
local Page3Button = Instance.new("TextButton")
local TextButton_Roundify_12px_6 = Instance.new("ImageLabel")
local Pacifist = Instance.new("TextButton")
local TextButton_Roundify_12px_7 = Instance.new("ImageLabel")
local UIGradient_8 = Instance.new("UIGradient")
local ChatBypass = Instance.new("TextButton")
local TextButton_Roundify_12px_8 = Instance.new("ImageLabel")
local UIGradient_9 = Instance.new("UIGradient")
local PreviousPage = Instance.new("TextButton")
local UIGradient_10 = Instance.new("UIGradient")
local Title_2 = Instance.new("TextLabel")

--Properties:

SniffHub.Name = "SniffHub"
SniffHub.Parent = game.Workspace

OpenClose.Name = "OpenClose"
OpenClose.Parent = SniffHub
OpenClose.BackgroundColor3 = Color3.fromRGB(63, 63, 63)
OpenClose.BorderColor3 = Color3.fromRGB(255, 255, 255)
OpenClose.BorderSizePixel = 2
OpenClose.Position = UDim2.new(0, 0, 0.745762706, 0)
OpenClose.Size = UDim2.new(0, 119, 0, 25)
OpenClose.Font = Enum.Font.Arcade
OpenClose.Text = "Open/Close Sniff Hub"
OpenClose.TextColor3 = Color3.fromRGB(255, 255, 255)
OpenClose.TextScaled = true
OpenClose.TextSize = 14.000
OpenClose.TextWrapped = true
OpenClose.MouseButton1Down:Connect(function()
	script.Parent.Click:Play()
	script.Parent.Parent.GUIFrame.Visible = not script.Parent.Parent.GUIFrame.Visible
end)

GUIFrame.Name = "GUIFrame"
GUIFrame.Parent = SniffHub
GUIFrame.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
GUIFrame.BackgroundTransparency = 1.000
GUIFrame.Position = UDim2.new(0.103953153, 0, 0.226857886, 0)
GUIFrame.Size = UDim2.new(0, 457, 0, 265)

Page1.Name = "Page1"
Page1.Parent = GUIFrame
Page1.BackgroundColor3 = Color3.fromRGB(65, 65, 65)
Page1.BorderColor3 = Color3.fromRGB(255, 255, 255)
Page1.BorderSizePixel = 4
Page1.Position = UDim2.new(-0.00206612051, 0, -0.0029874444, 0)
Page1.Size = UDim2.new(0, 457, 0, 265)

UIGradient.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(93, 0, 255)), ColorSequenceKeypoint.new(0.64, Color3.fromRGB(255, 255, 255)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 234, 0))}
UIGradient.Parent = Page1

ServerAdmin.Name = "ServerAdmin"
ServerAdmin.Parent = Page1
ServerAdmin.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ServerAdmin.BackgroundTransparency = 1.000
ServerAdmin.BorderSizePixel = 0
ServerAdmin.Position = UDim2.new(0.0541721731, 0, 0.386324197, 0)
ServerAdmin.Size = UDim2.new(0, 121, 0, 57)
ServerAdmin.ZIndex = 2
ServerAdmin.Font = Enum.Font.SourceSans
ServerAdmin.Text = "FE Server Admin"
ServerAdmin.TextColor3 = Color3.fromRGB(255, 255, 255)
ServerAdmin.TextScaled = true
ServerAdmin.TextSize = 14.000
ServerAdmin.TextWrapped = true
ServerAdmin.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/ONEReverseCard/My-Scripts/main/Netless%20Server%20Admin.md"))()
end)

TextButton_Roundify_12px.Name = "TextButton_Roundify_12px"
TextButton_Roundify_12px.Parent = ServerAdmin
TextButton_Roundify_12px.Active = true
TextButton_Roundify_12px.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton_Roundify_12px.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton_Roundify_12px.BackgroundTransparency = 1.000
TextButton_Roundify_12px.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton_Roundify_12px.Selectable = true
TextButton_Roundify_12px.Size = UDim2.new(1, 0, 1, 0)
TextButton_Roundify_12px.Image = "rbxassetid://3570695787"
TextButton_Roundify_12px.ImageColor3 = Color3.fromRGB(90, 90, 90)
TextButton_Roundify_12px.ScaleType = Enum.ScaleType.Slice
TextButton_Roundify_12px.SliceCenter = Rect.new(100, 100, 100, 100)
TextButton_Roundify_12px.SliceScale = 0.120

UIGradient_2.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 136, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 255))}
UIGradient_2.Parent = TextButton_Roundify_12px

Joy.Name = "Joy"
Joy.Parent = Page1
Joy.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Joy.BackgroundTransparency = 1.000
Joy.BorderSizePixel = 0
Joy.Position = UDim2.new(0.358329713, 0, 0.386324197, 0)
Joy.Size = UDim2.new(0, 121, 0, 57)
Joy.ZIndex = 2
Joy.Font = Enum.Font.SourceSans
Joy.Text = "FE Joy"
Joy.TextColor3 = Color3.fromRGB(255, 255, 255)
Joy.TextScaled = true
Joy.TextSize = 14.000
Joy.TextWrapped = true
Joy.MouseButton1Click:Connect(function()
	loadstring(game:HttpGetAsync("https://pastebin.com/raw/LEAQuKj0"))()
end)

TextButton_Roundify_12px_2.Name = "TextButton_Roundify_12px"
TextButton_Roundify_12px_2.Parent = Joy
TextButton_Roundify_12px_2.Active = true
TextButton_Roundify_12px_2.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton_Roundify_12px_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton_Roundify_12px_2.BackgroundTransparency = 1.000
TextButton_Roundify_12px_2.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton_Roundify_12px_2.Selectable = true
TextButton_Roundify_12px_2.Size = UDim2.new(1, 0, 1, 0)
TextButton_Roundify_12px_2.Image = "rbxassetid://3570695787"
TextButton_Roundify_12px_2.ImageColor3 = Color3.fromRGB(90, 90, 90)
TextButton_Roundify_12px_2.ScaleType = Enum.ScaleType.Slice
TextButton_Roundify_12px_2.SliceCenter = Rect.new(100, 100, 100, 100)
TextButton_Roundify_12px_2.SliceScale = 0.120

UIGradient_3.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 136, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 255))}
UIGradient_3.Parent = TextButton_Roundify_12px_2

MemeAnimations.Name = "MemeAnimations"
MemeAnimations.Parent = Page1
MemeAnimations.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
MemeAnimations.BackgroundTransparency = 1.000
MemeAnimations.BorderSizePixel = 0
MemeAnimations.Position = UDim2.new(0.69312185, 0, 0.386324197, 0)
MemeAnimations.Size = UDim2.new(0, 121, 0, 57)
MemeAnimations.ZIndex = 2
MemeAnimations.Font = Enum.Font.SourceSans
MemeAnimations.Text = "FE Meme Animations"
MemeAnimations.TextColor3 = Color3.fromRGB(255, 255, 255)
MemeAnimations.TextScaled = true
MemeAnimations.TextSize = 14.000
MemeAnimations.TextWrapped = true
MemeAnimations.MouseButton1Click:Connect(function()
	loadstring(game:HttpGetAsync("https://pastebin.com/raw/LEAQuKj0"))()
end)

TextButton_Roundify_12px_3.Name = "TextButton_Roundify_12px"
TextButton_Roundify_12px_3.Parent = MemeAnimations
TextButton_Roundify_12px_3.Active = true
TextButton_Roundify_12px_3.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton_Roundify_12px_3.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton_Roundify_12px_3.BackgroundTransparency = 1.000
TextButton_Roundify_12px_3.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton_Roundify_12px_3.Selectable = true
TextButton_Roundify_12px_3.Size = UDim2.new(1, 0, 1, 0)
TextButton_Roundify_12px_3.Image = "rbxassetid://3570695787"
TextButton_Roundify_12px_3.ImageColor3 = Color3.fromRGB(90, 90, 90)
TextButton_Roundify_12px_3.ScaleType = Enum.ScaleType.Slice
TextButton_Roundify_12px_3.SliceCenter = Rect.new(100, 100, 100, 100)
TextButton_Roundify_12px_3.SliceScale = 0.120

UIGradient_4.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 136, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 255))}
UIGradient_4.Parent = TextButton_Roundify_12px_3

Page2Button.Name = "Page2Button"
Page2Button.Parent = Page1
Page2Button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Page2Button.BackgroundTransparency = 1.000
Page2Button.BorderSizePixel = 0
Page2Button.Position = UDim2.new(0.351765156, 0, 0.680663824, 0)
Page2Button.Size = UDim2.new(0, 121, 0, 57)
Page2Button.ZIndex = 2
Page2Button.Font = Enum.Font.SourceSans
Page2Button.Text = "Page 2"
Page2Button.TextColor3 = Color3.fromRGB(255, 255, 255)
Page2Button.TextScaled = true
Page2Button.TextSize = 14.000
Page2Button.TextWrapped = true
Page2Button.MouseButton1Click:Connect(function()
	script.Parent.Parent.Parent.Page2.Visible = true
end)

TextButton_Roundify_12px_4.Name = "TextButton_Roundify_12px"
TextButton_Roundify_12px_4.Parent = Page2Button
TextButton_Roundify_12px_4.Active = true
TextButton_Roundify_12px_4.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton_Roundify_12px_4.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton_Roundify_12px_4.BackgroundTransparency = 1.000
TextButton_Roundify_12px_4.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton_Roundify_12px_4.Selectable = true
TextButton_Roundify_12px_4.Size = UDim2.new(1, 0, 1, 0)
TextButton_Roundify_12px_4.Image = "rbxassetid://3570695787"
TextButton_Roundify_12px_4.ImageColor3 = Color3.fromRGB(90, 90, 90)
TextButton_Roundify_12px_4.ScaleType = Enum.ScaleType.Slice
TextButton_Roundify_12px_4.SliceCenter = Rect.new(100, 100, 100, 100)
TextButton_Roundify_12px_4.SliceScale = 0.120

UIGradient_5.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(59, 0, 255)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 255))}
UIGradient_5.Parent = TextButton_Roundify_12px_4

TextLabel.Parent = GUIFrame
TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextLabel.BackgroundTransparency = 1.000
TextLabel.Position = UDim2.new(-0.00218818383, 0, 0.0226415098, 0)
TextLabel.Size = UDim2.new(0, 94, 0, 24)
TextLabel.Font = Enum.Font.SourceSans
TextLabel.Text = "Made by DZIDZIO0, Credits to sebee."
TextLabel.TextColor3 = Color3.fromRGB(136, 136, 136)
TextLabel.TextScaled = true
TextLabel.TextSize = 14.000
TextLabel.TextWrapped = true

Page2.Name = "Page2"
Page2.Parent = GUIFrame
Page2.BackgroundColor3 = Color3.fromRGB(65, 65, 65)
Page2.BorderColor3 = Color3.fromRGB(255, 255, 255)
Page2.BorderSizePixel = 4
Page2.Position = UDim2.new(-0.00206612051, 0, -0.0029874444, 0)
Page2.Size = UDim2.new(0, 457, 0, 265)
Page2.ZIndex = 3
Page2.Visible = false

UIGradient_6.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(93, 0, 255)), ColorSequenceKeypoint.new(0.64, Color3.fromRGB(255, 255, 255)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 234, 0))}
UIGradient_6.Parent = Page2

Title.Name = "Title"
Title.Parent = Page2
Title.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title.BackgroundTransparency = 1.000
Title.Position = UDim2.new(0.255474448, 0, 0.149193555, 0)
Title.Size = UDim2.new(0, 200, 0, 50)
Title.Font = Enum.Font.SourceSans
Title.Text = "Da Sniff Hub"
Title.TextColor3 = Color3.fromRGB(255, 255, 255)
Title.TextScaled = true
Title.TextSize = 14.000
Title.TextWrapped = true

GravityGun.Name = "GravityGun"
GravityGun.Parent = Page2
GravityGun.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
GravityGun.BackgroundTransparency = 1.000
GravityGun.BorderSizePixel = 0
GravityGun.Position = UDim2.new(0.358329713, 0, 0.386324197, 0)
GravityGun.Size = UDim2.new(0, 121, 0, 57)
GravityGun.ZIndex = 4
GravityGun.Font = Enum.Font.SourceSans
GravityGun.Text = "FE Telekinesis Gun (grab unanchored parts, everyone can see)"
GravityGun.TextColor3 = Color3.fromRGB(255, 255, 255)
GravityGun.TextScaled = true
GravityGun.TextSize = 14.000
GravityGun.TextWrapped = true
GravityGun.MouseButton1Click:Connect(function()
	function sandbox(var,func)
		local env = getfenv(func)
		local newenv = setmetatable({},{
			__index = function(self,k)
				if k=="script" then
					return var
				else
					return env[k]
				end
			end,
		})
		setfenv(func,newenv)
		return func
	end
	cors = {}
	mas = Instance.new("Model",game:GetService("Lighting"))
	Tool0 = Instance.new("Tool")
	Part1 = Instance.new("Part")
	CylinderMesh2 = Instance.new("CylinderMesh")
	Part3 = Instance.new("Part")
	LocalScript4 = Instance.new("LocalScript")
	Script5 = Instance.new("Script")
	LocalScript6 = Instance.new("LocalScript")
	Script7 = Instance.new("Script")
	LocalScript8 = Instance.new("LocalScript")
	Part9 = Instance.new("Part")
	Script10 = Instance.new("Script")
	Part11 = Instance.new("Part")
	Script12 = Instance.new("Script")
	Part13 = Instance.new("Part")
	Script14 = Instance.new("Script")
	Tool0.Name = "Telekinesis Gun"
	Tool0.Parent = mas
	Tool0.CanBeDropped = false
	Part1.Name = "Handle"
	Part1.Parent = Tool0
	Part1.Material = Enum.Material.Neon
	Part1.BrickColor = BrickColor.new("Cyan")
	Part1.Transparency = 1
	Part1.Rotation = Vector3.new(0, 15.4200001, 0)
	Part1.CanCollide = false
	Part1.FormFactor = Enum.FormFactor.Custom
	Part1.Size = Vector3.new(1, 0.400000036, 0.300000012)
	Part1.CFrame = CFrame.new(-55.2695465, 0.696546972, 0.383156985, 0.96399641, -4.98074878e-05, 0.265921414, 4.79998416e-05, 1, 1.32960558e-05, -0.265921414, -5.30653779e-08, 0.96399641)
	Part1.BottomSurface = Enum.SurfaceType.Smooth
	Part1.TopSurface = Enum.SurfaceType.Smooth
	Part1.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	Part1.Position = Vector3.new(-55.2695465, 0.696546972, 0.383156985)
	Part1.Orientation = Vector3.new(0, 15.4200001, 0)
	Part1.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	CylinderMesh2.Parent = Part1
	CylinderMesh2.Scale = Vector3.new(0.100000001, 0.100000001, 0.100000001)
	CylinderMesh2.Scale = Vector3.new(0.100000001, 0.100000001, 0.100000001)
	Part3.Name = "Shoot"
	Part3.Parent = Tool0
	Part3.Material = Enum.Material.Neon
	Part3.BrickColor = BrickColor.new("Cyan")
	Part3.Reflectance = 0.30000001192093
	Part3.Transparency = 1
	Part3.Rotation = Vector3.new(90.9799957, 0.25999999, -91.409996)
	Part3.CanCollide = false
	Part3.FormFactor = Enum.FormFactor.Custom
	Part3.Size = Vector3.new(0.200000003, 0.25, 0.310000032)
	Part3.CFrame = CFrame.new(-54.7998123, 0.774299085, -0.757350147, -0.0245519895, 0.99968797, 0.00460194098, 0.0169109926, 0.00501798885, -0.999844491, -0.999555528, -0.0244703442, -0.0170289185)
	Part3.BottomSurface = Enum.SurfaceType.Smooth
	Part3.TopSurface = Enum.SurfaceType.Smooth
	Part3.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	Part3.Position = Vector3.new(-54.7998123, 0.774299085, -0.757350147)
	Part3.Orientation = Vector3.new(88.9899979, 164.87999, 73.4700012)
	Part3.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	LocalScript4.Parent = Tool0
	table.insert(cors,sandbox(LocalScript4,function()
		-- Variables for services
		local render = game:GetService("RunService").RenderStepped
		local contextActionService = game:GetService("ContextActionService")
		local userInputService = game:GetService("UserInputService")

		local player = game.Players.LocalPlayer
		local mouse = player:GetMouse()
		local Tool = script.Parent

		-- Variables for Module Scripts
		local screenSpace = require(Tool:WaitForChild("ScreenSpace"))

		local connection
		-- Variables for character joints

		local neck, shoulder, oldNeckC0, oldShoulderC0 

		local mobileShouldTrack = true

		-- Thourough check to see if a character is sitting
		local function amISitting(character)
			local t = character.Torso
			for _, part in pairs(t:GetConnectedParts(true)) do
				if part:IsA("Seat") or part:IsA("VehicleSeat") then
					return true
				end
			end
		end

		-- Function to call on renderstepped. Orients the character so it is facing towards
		-- the player mouse's position in world space. If character is sitting then the torso
		-- should not track
		local function frame(mousePosition)
			-- Special mobile consideration. We don't want to track if the user was touching a ui
			-- element such as the movement controls. Just return out of function if so to make sure
			-- character doesn't track
			if not mobileShouldTrack then return end

			-- Make sure character isn't swiming. If the character is swimming the following code will
			-- not work well; the character will not swim correctly. Besides, who shoots underwater?
			if player.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Swimming then
				local torso = player.Character.Torso
				local head = player.Character.Head

				local toMouse = (mousePosition - head.Position).unit
				local angle = math.acos(toMouse:Dot(Vector3.new(0,1,0)))

				local neckAngle = angle

				-- Limit how much the head can tilt down. Too far and the head looks unnatural
				if math.deg(neckAngle) > 110 then
					neckAngle = math.rad(110)
				end
				neck.C0 = CFrame.new(0,1,0) * CFrame.Angles(math.pi - neckAngle,math.pi,0)

				-- Calculate horizontal rotation
				local arm = player.Character:FindFirstChild("Right Arm")
				local fromArmPos = torso.Position + torso.CFrame:vectorToWorldSpace(Vector3.new(
					torso.Size.X/2 + arm.Size.X/2, torso.Size.Y/2 - arm.Size.Z/2, 0))
				local toMouseArm = ((mousePosition - fromArmPos) * Vector3.new(1,0,1)).unit
				local look = (torso.CFrame.lookVector * Vector3.new(1,0,1)).unit
				local lateralAngle = math.acos(toMouseArm:Dot(look))		

				-- Check for rogue math
				if tostring(lateralAngle) == "-1.#IND" then
					lateralAngle = 0
				end		

				-- Handle case where character is sitting down
				if player.Character.Humanoid:GetState() == Enum.HumanoidStateType.Seated then			

					local cross = torso.CFrame.lookVector:Cross(toMouseArm)
					if lateralAngle > math.pi/2 then
						lateralAngle = math.pi/2
					end
					if cross.Y < 0 then
						lateralAngle = -lateralAngle
					end
				end	

				-- Turn shoulder to point to mouse
				shoulder.C0 = CFrame.new(1,0.5,0) * CFrame.Angles(math.pi/2 - angle,math.pi/2 + lateralAngle,0)	

				-- If not sitting then aim torso laterally towards mouse
				if not amISitting(player.Character) then
					torso.CFrame = CFrame.new(torso.Position, torso.Position + (Vector3.new(
						mousePosition.X, torso.Position.Y, mousePosition.Z)-torso.Position).unit)
				else
					--print("sitting")		
				end	
			end
		end

		-- Function to bind to render stepped if player is on PC
		local function pcFrame()
			frame(mouse.Hit.p)
		end

		-- Function to bind to touch moved if player is on mobile
		local function mobileFrame(touch, processed)
			-- Check to see if the touch was on a UI element. If so, we don't want to update anything
			if not processed then
				-- Calculate touch position in world space. Uses Stravant's ScreenSpace Module script
				-- to create a ray from the camera.
				local test = screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y, 1)
				local nearPos = game.Workspace.CurrentCamera.CoordinateFrame:vectorToWorldSpace(screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y, 1))
				nearPos = game.Workspace.CurrentCamera.CoordinateFrame.p - nearPos
				local farPos = screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y,50) 
				farPos = game.Workspace.CurrentCamera.CoordinateFrame:vectorToWorldSpace(farPos) * -1
				if farPos.magnitude > 900 then
					farPos = farPos.unit * 900
				end
				local ray = Ray.new(nearPos, farPos)
				local part, pos = game.Workspace:FindPartOnRay(ray, player.Character)

				-- if a position was found on the ray then update the character's rotation
				if pos then
					frame(pos)
				end
			end
		end

		local oldIcon = nil
		-- Function to bind to equip event
		local function equip()
			local torso = player.Character.Torso

			-- Setup joint variables
			neck = torso.Neck	
			oldNeckC0 = neck.C0
			shoulder = torso:FindFirstChild("Right Shoulder")
			oldShoulderC0 = shoulder.C0

			-- Remember old mouse icon and update current
			oldIcon = mouse.Icon
			mouse.Icon = "rbxassetid:// 2184939409"

			-- Bind TouchMoved event if on mobile. Otherwise connect to renderstepped
			if userInputService.TouchEnabled then
				connection = userInputService.TouchMoved:connect(mobileFrame)
			else
				connection = render:connect(pcFrame)
			end

			-- Bind TouchStarted and TouchEnded. Used to determine if character should rotate
			-- during touch input
			userInputService.TouchStarted:connect(function(touch, processed)
				mobileShouldTrack = not processed
			end)	
			userInputService.TouchEnded:connect(function(touch, processed)
				mobileShouldTrack = false
			end)

			-- Fire server's equip event
			game.ReplicatedStorage.ROBLOX_PistolEquipEvent:FireServer()

			-- Bind event for when mouse is clicked to fire server's fire event
			mouse.Button1Down:connect(function()
				game.ReplicatedStorage.ROBLOX_PistolFireEvent:FireServer(mouse.Hit.p)
			end)

			-- Bind reload event to mobile button and r key
			contextActionService:BindActionToInputTypes("Reload", function() 
				game.ReplicatedStorage.ROBLOX_PistolReloadEvent:FireServer()		
			end, true, "")

			-- If game uses filtering enabled then need to update server while tool is
			-- held by character.
			if workspace.FilteringEnabled then
				while connection do
					wait()
					game.ReplicatedStorage.ROBLOX_PistolUpdateEvent:FireServer(neck.C0, shoulder.C0)
				end
			end
		end

		-- Function to bind to Unequip event
		local function unequip()
			if connection then connection:disconnect() end
			contextActionService:UnbindAction("Reload")
			game.ReplicatedStorage.ROBLOX_PistolUnequipEvent:FireServer()
			mouse.Icon = oldIcon
			neck.C0 = oldNeckC0
			shoulder.C0 = oldShoulderC0
		end

		-- Bind tool events
		Tool.Equipped:connect(equip)
		Tool.Unequipped:connect(unequip)
	end))
	Script5.Name = "qPerfectionWeld"
	Script5.Parent = Tool0
	table.insert(cors,sandbox(Script5,function()
		-- Created by Quenty (@Quenty, follow me on twitter).
		-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
		-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

		-- qPerfectionWeld.lua
		-- Created 10/6/2014
		-- Author: Quenty
		-- Version 1.0.3

		-- Updated 10/14/2014 - Updated to 1.0.1
		--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

		-- Updated 10/14/2014 - Updated to 1.0.2
		--- Fixed bug fix. 

		-- Updated 10/14/2014 - Updated to 1.0.3
		--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

		local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


		local function CallOnChildren(Instance, FunctionToCall)
			-- Calls a function on each of the children of a certain object, using recursion.  

			FunctionToCall(Instance)

			for _, Child in next, Instance:GetChildren() do
				CallOnChildren(Child, FunctionToCall)
			end
		end

		local function GetNearestParent(Instance, ClassName)
			-- Returns the nearest parent of a certain class, or returns nil

			local Ancestor = Instance
			repeat
				Ancestor = Ancestor.Parent
				if Ancestor == nil then
					return nil
				end
			until Ancestor:IsA(ClassName)

			return Ancestor
		end

		local function GetBricks(StartInstance)
			local List = {}

			-- if StartInstance:IsA("BasePart") then
			-- 	List[#List+1] = StartInstance
			-- end

			CallOnChildren(StartInstance, function(Item)
				if Item:IsA("BasePart") then
					List[#List+1] = Item;
				end
			end)

			return List
		end

		local function Modify(Instance, Values)
			-- Modifies an Instance by using a table.  

			assert(type(Values) == "table", "Values is not a table");

			for Index, Value in next, Values do
				if type(Index) == "number" then
					Value.Parent = Instance
				else
					Instance[Index] = Value
				end
			end
			return Instance
		end

		local function Make(ClassType, Properties)
			-- Using a syntax hack to create a nice way to Make new items.  

			return Modify(Instance.new(ClassType), Properties)
		end

		local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
		local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

		local function HasWheelJoint(Part)
			for _, SurfaceName in pairs(Surfaces) do
				for _, HingSurfaceName in pairs(HingSurfaces) do
					if Part[SurfaceName].Name == HingSurfaceName then
						return true
					end
				end
			end

			return false
		end

		local function ShouldBreakJoints(Part)
			--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
			--  definitely some edge cases. 

			if NEVER_BREAK_JOINTS then
				return false
			end

			if HasWheelJoint(Part) then
				return false
			end

			local Connected = Part:GetConnectedParts()

			if #Connected == 1 then
				return false
			end

			for _, Item in pairs(Connected) do
				if HasWheelJoint(Item) then
					return false
				elseif not Item:IsDescendantOf(script.Parent) then
					return false
				end
			end

			return true
		end

		local function WeldTogether(Part0, Part1, JointType, WeldParent)
			--- Weld's 2 parts together
			-- @param Part0 The first part
			-- @param Part1 The second part (Dependent part most of the time).
			-- @param [JointType] The type of joint. Defaults to weld.
			-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
			-- @return The weld created.

			JointType = JointType or "Weld"
			local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")

			local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
			Modify(NewWeld, {
				Name = "qCFrameWeldThingy";
				Part0  = Part0;
				Part1  = Part1;
				C0     = CFrame.new();--Part0.CFrame:inverse();
				C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
				Parent = Part1;
			})

			if not RelativeValue then
				RelativeValue = Make("CFrameValue", {
					Parent     = Part1;
					Name       = "qRelativeCFrameWeldValue";
					Archivable = true;
					Value      = NewWeld.C1;
				})
			end

			return NewWeld
		end

		local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
			-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
			-- @param MainPart The part to weld the model to (can be in the model).
			-- @param [JointType] The type of joint. Defaults to weld. 
			-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.

			for _, Part in pairs(Parts) do
				if ShouldBreakJoints(Part) then
					Part:BreakJoints()
				end
			end

			for _, Part in pairs(Parts) do
				if Part ~= MainPart then
					WeldTogether(MainPart, Part, JointType, MainPart)
				end
			end

			if not DoNotUnanchor then
				for _, Part in pairs(Parts) do
					Part.Anchored = false
				end
				MainPart.Anchored = false
			end
		end

		local function PerfectionWeld()	
			local Tool = GetNearestParent(script, "Tool")

			local Parts = GetBricks(script.Parent)
			local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

			if PrimaryPart then
				WeldParts(Parts, PrimaryPart, "Weld", false)
			else
				warn("qWeld - Unable to weld part")
			end

			return Tool
		end

		local Tool = PerfectionWeld()


		if Tool and script.ClassName == "Script" then
			--- Don't bother with local scripts

			script.Parent.AncestryChanged:connect(function()
				PerfectionWeld()
			end)
		end

		-- Created by Quenty (@Quenty, follow me on twitter).

	end))
	LocalScript6.Name = "Animate"
	LocalScript6.Parent = Tool0
	table.insert(cors,sandbox(LocalScript6,function()
		local arms = nil
		local torso = nil
		local welds = {}
		local Tool = script.Parent
		local neck = nil
		local orginalC0 = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)

		function Equip(mouse)
			wait(0.01)
			arms = {Tool.Parent:FindFirstChild("Left Arm"), Tool.Parent:FindFirstChild("Right Arm")}
			head = Tool.Parent:FindFirstChild("Head") 
			torso = Tool.Parent:FindFirstChild("Torso")
			if neck == nil then 
				neck = Tool.Parent:FindFirstChild("Torso").Neck
			end 
			if arms ~= nil and torso ~= nil then
				local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
				if sh ~= nil then
					local yes = true
					if yes then
						yes = false
						sh[1].Part1 = nil
						sh[2].Part1 = nil
						local weld1 = Instance.new("Weld")
						weld1.Part0 = head
						weld1.Parent = head
						weld1.Part1 = arms[1]
						welds[1] = weld1
						local weld2 = Instance.new("Weld")
						weld2.Part0 = head
						weld2.Parent = head
						weld2.Part1 = arms[2]
						welds[2] = weld2
						-------------------------here
						weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
						weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
						mouse.Move:connect(function ()
							--local Direction = Tool.Direction.Value 
							local Direction = mouse.Hit.p
							local b = head.Position.Y-Direction.Y
							local dist = (head.Position-Direction).magnitude
							local answer = math.asin(b/dist)
							neck.C0=orginalC0*CFrame.fromEulerAnglesXYZ(answer,0,0)
							wait(0.1)
						end)end
				else
					print("sh")
				end
			else
				print("arms")
			end
		end

		function Unequip(mouse)
			if arms ~= nil and torso ~= nil then
				local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
				if sh ~= nil then
					local yes = true
					if yes then
						yes = false
						neck.C0 = orginalC0

						sh[1].Part1 = arms[1]
						sh[2].Part1 = arms[2]
						welds[1].Parent = nil
						welds[2].Parent = nil
					end
				else
					print("sh")
				end
			else
				print("arms")
			end
		end
		Tool.Equipped:connect(Equip)
		Tool.Unequipped:connect(Unequip)

		function Animate()
			arms = {Tool.Parent:FindFirstChild("Left Arm"), Tool.Parent:FindFirstChild("Right Arm")}
			if Tool.AnimateValue.Value == "Shoot" then 
				local weld1 = welds[1]
				local weld2 = welds[2]
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
				wait(0.00001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.05, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
				wait(0.00001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.1, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-95), math.rad(-15), 0)
				wait(0.00001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.3, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-110), math.rad(-15), 0)
				wait(0.00001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.35, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-115), math.rad(-15), 0)
				wait(0.00001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
				wait(0.00001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)	
				Tool.AnimateValue.Value = "None"
			end 
			if Tool.AnimateValue.Value == "Reload" then 
				local weld1 = welds[1]
				local weld2 = welds[2]
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-95), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-100), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-105), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-110), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-115), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.45, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.9, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.5, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 1, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.55, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 1.1, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.57, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 1.2, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.6, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 1.3, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.6, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
				wait(0.0001)
				weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
				weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)	
				Tool.AnimateValue.Value = "None"
			end 
		end 

		Tool.AnimateValue.Changed:connect(Animate)

	end))
	Script7.Name = "LineConnect"
	Script7.Parent = Tool0
	Script7.Disabled = true
	table.insert(cors,sandbox(Script7,function()
		wait()
		local check = script.Part2
		local part1 = script.Part1.Value
		local part2 = script.Part2.Value
		local parent = script.Par.Value
		local color = script.Color
		local line = Instance.new("Part")
		line.TopSurface = 0
		line.BottomSurface = 0
		line.Reflectance = .5
		line.Name = "Laser"
		line.Transparency = 0.6
		line.Locked = true
		line.CanCollide = false
		line.Anchored = true
		line.formFactor = 0
		line.Size = Vector3.new(0.4,0.4,1)
		local mesh = Instance.new("BlockMesh")
		mesh.Parent = line
		while true do
			if (check.Value==nil) then break end
			if (part1==nil or part2==nil or parent==nil) then break end
			if (part1.Parent==nil or part2.Parent==nil) then break end
			if (parent.Parent==nil) then break end
			local lv = CFrame.new(part1.Position,part2.Position)
			local dist = (part1.Position-part2.Position).magnitude
			line.Parent = parent
			line.Material = "Neon"
			line.BrickColor = color.Value.BrickColor
			line.Reflectance = color.Value.Reflectance
			line.Transparency = "0.2"
			line.CFrame = CFrame.new(part1.Position+lv.lookVector*dist/2)
			line.CFrame = CFrame.new(line.Position,part2.Position)
			mesh.Scale = Vector3.new(.25,.25,dist)
			wait()
		end
		line:remove()
		script:remove() 
	end))
	LocalScript8.Name = "MainScript"
	LocalScript8.Parent = Tool0
	table.insert(cors,sandbox(LocalScript8,function()
		--Physics gun created by Killersoldier45
		wait() 
		tool = script.Parent
		lineconnect = tool.LineConnect
		object = nil
		mousedown = false
		found = false
		BP = Instance.new("BodyPosition")
		BP.maxForce = Vector3.new(math.huge*math.huge,math.huge*math.huge,math.huge*math.huge) --pwns everyone elses bodyposition
		BP.P = BP.P*10 --faster movement. less bounceback.
		dist = nil
		point = Instance.new("Part")
		point.Locked = true
		point.Anchored = true
		point.formFactor = 0
		point.Shape = 0
		point.Material = 'Neon'
		point.BrickColor = BrickColor.new("Toothpaste")
		point.Size = Vector3.new(1,1,1)
		point.CanCollide = false
		local mesh = Instance.new("SpecialMesh")
		mesh.MeshType = "Sphere"
		mesh.Scale = Vector3.new(.2,.2,.2)
		mesh.Parent = point
		handle = tool.Shoot
		front = tool.Shoot
		color = tool.Shoot
		objval = nil
		local hooked = false 
		local hookBP = BP:clone() 
		hookBP.maxForce = Vector3.new(30000,30000,30000) 

		function LineConnect(part1,part2,parent)
			local p1 = Instance.new("ObjectValue")
			p1.Value = part1
			p1.Name = "Part1"
			local p2 = Instance.new("ObjectValue")
			p2.Value = part2
			p2.Name = "Part2"
			local par = Instance.new("ObjectValue")
			par.Value = parent
			par.Name = "Par"
			local col = Instance.new("ObjectValue")
			col.Value = color
			col.Name = "Color"
			local s = lineconnect:clone()
			s.Disabled = false
			p1.Parent = s
			p2.Parent = s
			par.Parent = s
			col.Parent = s
			s.Parent = workspace
			if (part2==object) then
				objval = p2
			end
		end

		function onButton1Down(mouse)
			if (mousedown==true) then return end
			mousedown = true
			coroutine.resume(coroutine.create(function()
				local p = point:clone()
				p.Parent = tool
				LineConnect(front,p,workspace)
				while (mousedown==true) do
					p.Parent = tool
					if (object==nil) then
						if (mouse.Target==nil) then
							local lv = CFrame.new(front.Position,mouse.Hit.p)
							p.CFrame = CFrame.new(front.Position+(lv.lookVector*1000))
						else
							p.CFrame = CFrame.new(mouse.Hit.p)
						end
					else
						LineConnect(front,object,workspace)
						break
					end
					wait()
				end
				p:remove()
			end))
			while (mousedown==true) do
				if (mouse.Target~=nil) then
					local t = mouse.Target
					if (t.Anchored==false) then
						object = t
						dist = (object.Position-front.Position).magnitude
						break
					end
				end
				wait()
			end
			while (mousedown==true) do
				if (object.Parent==nil) then break end
				local lv = CFrame.new(front.Position,mouse.Hit.p)
				BP.Parent = object
				BP.position = front.Position+lv.lookVector*dist
				wait()
			end
			BP:remove()
			object = nil
			objval.Value = nil
		end

		function onKeyDown(key,mouse) 
			local key = key:lower() 
			local yesh = false 
			if (key=="q") then 
				if (dist>=5) then 
					dist = dist-5 
				end 
			end 
			if key == "t" then 
				if (object==nil) then return end 
				for _,v in pairs(object:children()) do 
					if v.className == "BodyGyro" then 
						return nil 
					end 
				end 
				BG = Instance.new("BodyGyro") 
				BG.maxTorque = Vector3.new(math.huge,math.huge,math.huge) 
				BG.cframe = CFrame.new(object.CFrame.p) 
				BG.Parent = object 
				repeat wait() until(object.CFrame == CFrame.new(object.CFrame.p)) 
				BG.Parent = nil 
				if (object==nil) then return end 
				for _,v in pairs(object:children()) do 
					if v.className == "BodyGyro" then 
						v.Parent = nil 
					end 
				end 
				object.Velocity = Vector3.new(0,0,0) 
				object.RotVelocity = Vector3.new(0,0,0) 
			end 
			if (key=="e") then
				dist = dist+5
			end
			if (string.byte(key)==27) then 
				if (object==nil) then return end
				local e = Instance.new("Explosion")
				e.Parent = workspace
				e.Position = object.Position
				color.BrickColor = BrickColor.Black()
				point.BrickColor = BrickColor.White() 
				wait(.48)
				color.BrickColor = BrickColor.White() 
				point.BrickColor = BrickColor.Black() 
			end
			if (key=="") then 
				if not hooked then 
					if (object==nil) then return end 
					hooked = true 
					hookBP.position = object.Position 
					if tool.Parent:findFirstChild("Torso") then 
						hookBP.Parent = tool.Parent.Torso 
						if dist ~= (object.Size.x+object.Size.y+object.Size.z)+5 then 
							dist = (object.Size.x+object.Size.y+object.Size.z)+5 
						end 
					end 
				else 
					hooked = false 
					hookBP.Parent = nil 
				end 
			end 
			if (key=="r") then 
				if (object==nil) then return end 
				color.BrickColor = BrickColor.new("Toothpaste") 
				point.BrickColor = BrickColor.new("Toothpaste") 
				object.Parent = nil 
				wait(.48) 
				color.BrickColor = BrickColor.new("Toothpaste")
				point.BrickColor = BrickColor.new("Toothpaste")
			end 
			if (key=="x") then 
				if (object==nil) then return end 
				local New = object:clone() 
				New.Parent = object.Parent 
				for _,v in pairs(New:children()) do 
					if v.className == "BodyPosition" or v.className == "BodyGyro" then 
						v.Parent = nil 
					end 
				end 
				object = New 
				mousedown = false 
				mousedown = true 
				LineConnect(front,object,workspace) 
				while (mousedown==true) do
					if (object.Parent==nil) then break end
					local lv = CFrame.new(front.Position,mouse.Hit.p)
					BP.Parent = object
					BP.position = front.Position+lv.lookVector*dist
					wait()
				end
				BP:remove()
				object = nil
				objval.Value = nil
			end 
			if (key=="c") then 
				local Cube = Instance.new("Part") 
				Cube.Locked = true 
				Cube.Size = Vector3.new(4,4,4) 
				Cube.formFactor = 0 
				Cube.TopSurface = 0 
				Cube.BottomSurface = 0 
				Cube.Name = "WeightedStorageCube" 
				Cube.Parent = workspace 
				Cube.CFrame = CFrame.new(mouse.Hit.p) + Vector3.new(0,2,0) 
				for i = 0,5 do 
					local Decal = Instance.new("Decal") 
					Decal.Texture = "http://www.roblox.com/asset/?id=2662260" 
					Decal.Face = i 
					Decal.Name = "WeightedStorageCubeDecal" 
					Decal.Parent = Cube 
				end 
			end 
			if (key=="") then 
				if dist ~= 15 then 
					dist = 15 
				end 
			end 
		end

		function onEquipped(mouse)
			keymouse = mouse
			local char = tool.Parent
			human = char.Humanoid
			human.Changed:connect(function() if (human.Health==0) then mousedown = false BP:remove() point:remove() tool:remove() end end)
			mouse.Button1Down:connect(function() onButton1Down(mouse) end)
			mouse.Button1Up:connect(function() mousedown = false end)
			mouse.KeyDown:connect(function(key) onKeyDown(key,mouse) end)
			mouse.Icon = "rbxassetid://2184939409"
		end

		tool.Equipped:connect(onEquipped)
	end))
	Part9.Name = "GlowPart"
	Part9.Parent = Tool0
	Part9.Material = Enum.Material.Neon
	Part9.BrickColor = BrickColor.new("Cyan")
	Part9.Transparency = 0.5
	Part9.Rotation = Vector3.new(0, -89.5899963, 0)
	Part9.Shape = Enum.PartType.Cylinder
	Part9.Size = Vector3.new(1.20000005, 0.649999976, 2)
	Part9.CFrame = CFrame.new(-54.8191681, 0.773548007, -0.0522949994, 0.00736002205, 4.68389771e-11, -0.999974668, 4.72937245e-11, 1, 1.41590961e-10, 0.999974668, 5.09317033e-11, 0.00736002252)
	Part9.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	Part9.Position = Vector3.new(-54.8191681, 0.773548007, -0.0522949994)
	Part9.Orientation = Vector3.new(0, -89.5799942, 0)
	Part9.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	Script10.Name = "Glow Script"
	Script10.Parent = Part9
	table.insert(cors,sandbox(Script10,function()
		while true do
			wait(0.05)
			script.Parent.Transparency = .5
			wait(0.05)
			script.Parent.Transparency = .6
			wait(0.05)
			script.Parent.Transparency = .7
			wait(0.05)
			script.Parent.Transparency = .8
			wait(0.05)
			script.Parent.Transparency = .9
			wait(0.05)
			script.Parent.Transparency = .8
			wait(0.05)
			script.Parent.Transparency = .7
			wait(0.05)
			script.Parent.Transparency = .6
			wait(0.05)
			script.Parent.Transparency = .5
		end

	end))
	Part11.Name = "GlowPart"
	Part11.Parent = Tool0
	Part11.Material = Enum.Material.Neon
	Part11.BrickColor = BrickColor.new("Cyan")
	Part11.Transparency = 0.5
	Part11.Rotation = Vector3.new(-89.3799973, -55.7399979, -89.25)
	Part11.Size = Vector3.new(0.280000001, 0.25999999, 0.200000003)
	Part11.CFrame = CFrame.new(-54.9808807, 0.99843204, 0.799362957, 0.00736002205, 0.562958956, -0.826454222, 4.72937245e-11, 0.826475084, 0.56297338, 0.999974668, -0.00414349511, 0.00608287565)
	Part11.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	Part11.Position = Vector3.new(-54.9808807, 0.99843204, 0.799362957)
	Part11.Orientation = Vector3.new(-34.2599983, -89.5799942, 0)
	Part11.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	Script12.Name = "Glow Script"
	Script12.Parent = Part11
	table.insert(cors,sandbox(Script12,function()
		while true do
			wait(0.05)
			script.Parent.Transparency = .5
			wait(0.05)
			script.Parent.Transparency = .6
			wait(0.05)
			script.Parent.Transparency = .7
			wait(0.05)
			script.Parent.Transparency = .8
			wait(0.05)
			script.Parent.Transparency = .9
			wait(0.05)
			script.Parent.Transparency = .8
			wait(0.05)
			script.Parent.Transparency = .7
			wait(0.05)
			script.Parent.Transparency = .6
			wait(0.05)
			script.Parent.Transparency = .5
		end

	end))
	Part13.Name = "GlowPart"
	Part13.Parent = Tool0
	Part13.Material = Enum.Material.Neon
	Part13.BrickColor = BrickColor.new("Cyan")
	Part13.Transparency = 0.5
	Part13.Rotation = Vector3.new(95.1500015, -53.8199997, 98.0799942)
	Part13.Size = Vector3.new(0.280000001, 0.25999999, 0.200000003)
	Part13.CFrame = CFrame.new(-54.5909271, 0.978429973, 0.799362957, -0.0830051303, -0.584483683, -0.807150841, 0.0241250042, 0.808528602, -0.58796227, 0.996258855, -0.0682764053, -0.0530113392)
	Part13.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	Part13.Position = Vector3.new(-54.5909271, 0.978429973, 0.799362957)
	Part13.Orientation = Vector3.new(36.0099983, -93.7599945, 1.70999992)
	Part13.Color = Color3.new(0.0156863, 0.686275, 0.92549)
	Script14.Name = "Glow Script"
	Script14.Parent = Part13
	table.insert(cors,sandbox(Script14,function()
		while true do
			wait(0.05)
			script.Parent.Transparency = .5
			wait(0.05)
			script.Parent.Transparency = .6
			wait(0.05)
			script.Parent.Transparency = .7
			wait(0.05)
			script.Parent.Transparency = .8
			wait(0.05)
			script.Parent.Transparency = .9
			wait(0.05)
			script.Parent.Transparency = .8
			wait(0.05)
			script.Parent.Transparency = .7
			wait(0.05)
			script.Parent.Transparency = .6
			wait(0.05)
			script.Parent.Transparency = .5
		end

	end))
	for i,v in pairs(mas:GetChildren()) do
		v.Parent = game:GetService("Players").LocalPlayer.Backpack
		pcall(function() v:MakeJoints() end)
	end
	mas:Destroy()
	for i,v in pairs(cors) do
		spawn(function()
			pcall(v)
		end)
	end
end)

TextButton_Roundify_12px_5.Name = "TextButton_Roundify_12px"
TextButton_Roundify_12px_5.Parent = GravityGun
TextButton_Roundify_12px_5.Active = true
TextButton_Roundify_12px_5.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton_Roundify_12px_5.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton_Roundify_12px_5.BackgroundTransparency = 1.000
TextButton_Roundify_12px_5.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton_Roundify_12px_5.Selectable = true
TextButton_Roundify_12px_5.Size = UDim2.new(1, 0, 1, 0)
TextButton_Roundify_12px_5.ZIndex = 3
TextButton_Roundify_12px_5.Image = "rbxassetid://3570695787"
TextButton_Roundify_12px_5.ImageColor3 = Color3.fromRGB(90, 90, 90)
TextButton_Roundify_12px_5.ScaleType = Enum.ScaleType.Slice
TextButton_Roundify_12px_5.SliceCenter = Rect.new(100, 100, 100, 100)
TextButton_Roundify_12px_5.SliceScale = 0.120

UIGradient_7.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 255, 29)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 255))}
UIGradient_7.Parent = TextButton_Roundify_12px_5

Page3Button.Name = "Page3Button"
Page3Button.Parent = Page2
Page3Button.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Page3Button.BackgroundTransparency = 1.000
Page3Button.BorderSizePixel = 0
Page3Button.Position = UDim2.new(0.351765156, 0, 0.680663824, 0)
Page3Button.Size = UDim2.new(0, 121, 0, 57)
Page3Button.ZIndex = 4
Page3Button.Font = Enum.Font.SourceSans
Page3Button.Text = "Page 3 (Coming Soon)"
Page3Button.TextColor3 = Color3.fromRGB(255, 255, 255)
Page3Button.TextScaled = true
Page3Button.TextSize = 14.000
Page3Button.TextWrapped = true

TextButton_Roundify_12px_6.Name = "TextButton_Roundify_12px"
TextButton_Roundify_12px_6.Parent = Page3Button
TextButton_Roundify_12px_6.Active = true
TextButton_Roundify_12px_6.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton_Roundify_12px_6.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton_Roundify_12px_6.BackgroundTransparency = 1.000
TextButton_Roundify_12px_6.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton_Roundify_12px_6.Selectable = true
TextButton_Roundify_12px_6.Size = UDim2.new(1, 0, 1, 0)
TextButton_Roundify_12px_6.ZIndex = 3
TextButton_Roundify_12px_6.Image = "rbxassetid://3570695787"
TextButton_Roundify_12px_6.ImageColor3 = Color3.fromRGB(90, 90, 90)
TextButton_Roundify_12px_6.ScaleType = Enum.ScaleType.Slice
TextButton_Roundify_12px_6.SliceCenter = Rect.new(100, 100, 100, 100)
TextButton_Roundify_12px_6.SliceScale = 0.120

Pacifist.Name = "Pacifist"
Pacifist.Parent = Page2
Pacifist.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Pacifist.BackgroundTransparency = 1.000
Pacifist.BorderSizePixel = 0
Pacifist.Position = UDim2.new(0.0585485399, 0, 0.386324197, 0)
Pacifist.Size = UDim2.new(0, 121, 0, 57)
Pacifist.ZIndex = 4
Pacifist.Font = Enum.Font.SourceSans
Pacifist.Text = "FE Pacifist"
Pacifist.TextColor3 = Color3.fromRGB(255, 255, 255)
Pacifist.TextScaled = true
Pacifist.TextSize = 14.000
Pacifist.TextWrapped = true

TextButton_Roundify_12px_7.Name = "TextButton_Roundify_12px"
TextButton_Roundify_12px_7.Parent = Pacifist
TextButton_Roundify_12px_7.Active = true
TextButton_Roundify_12px_7.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton_Roundify_12px_7.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton_Roundify_12px_7.BackgroundTransparency = 1.000
TextButton_Roundify_12px_7.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton_Roundify_12px_7.Selectable = true
TextButton_Roundify_12px_7.Size = UDim2.new(1, 0, 1, 0)
TextButton_Roundify_12px_7.ZIndex = 3
TextButton_Roundify_12px_7.Image = "rbxassetid://3570695787"
TextButton_Roundify_12px_7.ImageColor3 = Color3.fromRGB(90, 90, 90)
TextButton_Roundify_12px_7.ScaleType = Enum.ScaleType.Slice
TextButton_Roundify_12px_7.SliceCenter = Rect.new(100, 100, 100, 100)
TextButton_Roundify_12px_7.SliceScale = 0.120

UIGradient_8.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 128, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 255))}
UIGradient_8.Parent = TextButton_Roundify_12px_7

ChatBypass.Name = "ChatBypass"
ChatBypass.Parent = Page2
ChatBypass.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
ChatBypass.BackgroundTransparency = 1.000
ChatBypass.BorderSizePixel = 0
ChatBypass.Position = UDim2.new(0.664675474, 0, 0.386324197, 0)
ChatBypass.Size = UDim2.new(0, 121, 0, 57)
ChatBypass.ZIndex = 4
ChatBypass.Font = Enum.Font.SourceSans
ChatBypass.Text = "FE Chat Bypass"
ChatBypass.TextColor3 = Color3.fromRGB(255, 255, 255)
ChatBypass.TextScaled = true
ChatBypass.TextSize = 14.000
ChatBypass.TextWrapped = true
script.Parent.MouseButton1Click:Connect(function()
	loadstring(game:HttpGet("https://the-shed.xyz/roblox/scripts/ChatBypass", true))()
end)

TextButton_Roundify_12px_8.Name = "TextButton_Roundify_12px"
TextButton_Roundify_12px_8.Parent = ChatBypass
TextButton_Roundify_12px_8.Active = true
TextButton_Roundify_12px_8.AnchorPoint = Vector2.new(0.5, 0.5)
TextButton_Roundify_12px_8.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
TextButton_Roundify_12px_8.BackgroundTransparency = 1.000
TextButton_Roundify_12px_8.Position = UDim2.new(0.5, 0, 0.5, 0)
TextButton_Roundify_12px_8.Selectable = true
TextButton_Roundify_12px_8.Size = UDim2.new(1, 0, 1, 0)
TextButton_Roundify_12px_8.ZIndex = 3
TextButton_Roundify_12px_8.Image = "rbxassetid://3570695787"
TextButton_Roundify_12px_8.ImageColor3 = Color3.fromRGB(90, 90, 90)
TextButton_Roundify_12px_8.ScaleType = Enum.ScaleType.Slice
TextButton_Roundify_12px_8.SliceCenter = Rect.new(100, 100, 100, 100)
TextButton_Roundify_12px_8.SliceScale = 0.120

UIGradient_9.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(255, 128, 0)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(255, 255, 255))}
UIGradient_9.Parent = TextButton_Roundify_12px_8

PreviousPage.Name = "PreviousPage"
PreviousPage.Parent = Page2
PreviousPage.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
PreviousPage.BorderSizePixel = 0
PreviousPage.Position = UDim2.new(0.617064238, 0, 0.0226415098, 0)
PreviousPage.Size = UDim2.new(0, 174, 0, 46)
PreviousPage.ZIndex = 4
PreviousPage.Font = Enum.Font.SourceSans
PreviousPage.Text = "Previous Page"
PreviousPage.TextColor3 = Color3.fromRGB(17, 0, 57)
PreviousPage.TextScaled = true
PreviousPage.TextSize = 14.000
PreviousPage.TextWrapped = true
PreviousPage.MouseButton1Down:Connect(function()
	
		Page2.Visible = false

end)

UIGradient_10.Color = ColorSequence.new{ColorSequenceKeypoint.new(0.00, Color3.fromRGB(59, 0, 255)), ColorSequenceKeypoint.new(1.00, Color3.fromRGB(59, 255, 0))}
UIGradient_10.Parent = PreviousPage

Title_2.Name = "Title"
Title_2.Parent = GUIFrame
Title_2.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
Title_2.BackgroundTransparency = 1.000
Title_2.Position = UDim2.new(0.255474448, 0, 0.149193555, 0)
Title_2.Size = UDim2.new(0, 200, 0, 50)
Title_2.Font = Enum.Font.SourceSans
Title_2.Text = "Da Sniff Hub"
Title_2.TextColor3 = Color3.fromRGB(255, 255, 255)
Title_2.TextScaled = true
Title_2.TextSize = 14.000
Title_2.TextWrapped = true

-- Scripts:

local function RSXT_fake_script() -- OpenClose.LocalScript 
	local script = Instance.new('LocalScript', OpenClose)

	script.Parent.MouseButton1Down:Connect(function()
		script.Parent.Click:Play()
		script.Parent.Parent.GUIFrame.Visible = not script.Parent.Parent.GUIFrame.Visible
	end)
end
coroutine.wrap(RSXT_fake_script)()
local function SFLQ_fake_script() -- ServerAdmin.LocalScript 
	local script = Instance.new('LocalScript', ServerAdmin)

	script.Parent.MouseButton1Click:Connect(function()
		loadstring(game:HttpGet("https://raw.githubusercontent.com/ONEReverseCard/My-Scripts/main/Netless%20Server%20Admin.md"))()
	end)
end
coroutine.wrap(SFLQ_fake_script)()
local function TULJST_fake_script() -- Joy.LocalScript 
	local script = Instance.new('LocalScript', Joy)

	script.Parent.MouseButton1Click:Connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/LEAQuKj0"))()
	end)
end
coroutine.wrap(TULJST_fake_script)()
local function DMMXQ_fake_script() -- MemeAnimations.LocalScript 
	local script = Instance.new('LocalScript', MemeAnimations)

	script.Parent.MouseButton1Click:Connect(function()
		loadstring(game:HttpGetAsync("https://pastebin.com/raw/LEAQuKj0"))()
	end)
end
coroutine.wrap(DMMXQ_fake_script)()
local function OPDEMFI_fake_script() -- Page2Button.LocalScript 
	local script = Instance.new('LocalScript', Page2Button)

	script.Parent.MouseButton1Click:Connect(function()
		script.Parent.Parent.Parent.Page2.Visible = true
	end)
end
coroutine.wrap(OPDEMFI_fake_script)()
local function RJEXVH_fake_script() -- GUIFrame.Script 
	local script = Instance.new('Script', GUIFrame)

	script.Parent.Draggable = true
end
coroutine.wrap(RJEXVH_fake_script)()
local function YIBDDCZ_fake_script() -- GravityGun.LocalScript 
	local script = Instance.new('LocalScript', GravityGun)

	script.Parent.MouseButton1Click:Connect(function()
		function sandbox(var,func)
			local env = getfenv(func)
			local newenv = setmetatable({},{
				__index = function(self,k)
					if k=="script" then
						return var
					else
						return env[k]
					end
				end,
			})
			setfenv(func,newenv)
			return func
		end
		cors = {}
		mas = Instance.new("Model",game:GetService("Lighting"))
		Tool0 = Instance.new("Tool")
		Part1 = Instance.new("Part")
		CylinderMesh2 = Instance.new("CylinderMesh")
		Part3 = Instance.new("Part")
		LocalScript4 = Instance.new("LocalScript")
		Script5 = Instance.new("Script")
		LocalScript6 = Instance.new("LocalScript")
		Script7 = Instance.new("Script")
		LocalScript8 = Instance.new("LocalScript")
		Part9 = Instance.new("Part")
		Script10 = Instance.new("Script")
		Part11 = Instance.new("Part")
		Script12 = Instance.new("Script")
		Part13 = Instance.new("Part")
		Script14 = Instance.new("Script")
		Tool0.Name = "Telekinesis Gun"
		Tool0.Parent = mas
		Tool0.CanBeDropped = false
		Part1.Name = "Handle"
		Part1.Parent = Tool0
		Part1.Material = Enum.Material.Neon
		Part1.BrickColor = BrickColor.new("Cyan")
		Part1.Transparency = 1
		Part1.Rotation = Vector3.new(0, 15.4200001, 0)
		Part1.CanCollide = false
		Part1.FormFactor = Enum.FormFactor.Custom
		Part1.Size = Vector3.new(1, 0.400000036, 0.300000012)
		Part1.CFrame = CFrame.new(-55.2695465, 0.696546972, 0.383156985, 0.96399641, -4.98074878e-05, 0.265921414, 4.79998416e-05, 1, 1.32960558e-05, -0.265921414, -5.30653779e-08, 0.96399641)
		Part1.BottomSurface = Enum.SurfaceType.Smooth
		Part1.TopSurface = Enum.SurfaceType.Smooth
		Part1.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		Part1.Position = Vector3.new(-55.2695465, 0.696546972, 0.383156985)
		Part1.Orientation = Vector3.new(0, 15.4200001, 0)
		Part1.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		CylinderMesh2.Parent = Part1
		CylinderMesh2.Scale = Vector3.new(0.100000001, 0.100000001, 0.100000001)
		CylinderMesh2.Scale = Vector3.new(0.100000001, 0.100000001, 0.100000001)
		Part3.Name = "Shoot"
		Part3.Parent = Tool0
		Part3.Material = Enum.Material.Neon
		Part3.BrickColor = BrickColor.new("Cyan")
		Part3.Reflectance = 0.30000001192093
		Part3.Transparency = 1
		Part3.Rotation = Vector3.new(90.9799957, 0.25999999, -91.409996)
		Part3.CanCollide = false
		Part3.FormFactor = Enum.FormFactor.Custom
		Part3.Size = Vector3.new(0.200000003, 0.25, 0.310000032)
		Part3.CFrame = CFrame.new(-54.7998123, 0.774299085, -0.757350147, -0.0245519895, 0.99968797, 0.00460194098, 0.0169109926, 0.00501798885, -0.999844491, -0.999555528, -0.0244703442, -0.0170289185)
		Part3.BottomSurface = Enum.SurfaceType.Smooth
		Part3.TopSurface = Enum.SurfaceType.Smooth
		Part3.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		Part3.Position = Vector3.new(-54.7998123, 0.774299085, -0.757350147)
		Part3.Orientation = Vector3.new(88.9899979, 164.87999, 73.4700012)
		Part3.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		LocalScript4.Parent = Tool0
		table.insert(cors,sandbox(LocalScript4,function()
			-- Variables for services
			local render = game:GetService("RunService").RenderStepped
			local contextActionService = game:GetService("ContextActionService")
			local userInputService = game:GetService("UserInputService")
	
			local player = game.Players.LocalPlayer
			local mouse = player:GetMouse()
			local Tool = script.Parent
	
			-- Variables for Module Scripts
			local screenSpace = require(Tool:WaitForChild("ScreenSpace"))
	
			local connection
			-- Variables for character joints
	
			local neck, shoulder, oldNeckC0, oldShoulderC0 
	
			local mobileShouldTrack = true
	
			-- Thourough check to see if a character is sitting
			local function amISitting(character)
				local t = character.Torso
				for _, part in pairs(t:GetConnectedParts(true)) do
					if part:IsA("Seat") or part:IsA("VehicleSeat") then
						return true
					end
				end
			end
	
			-- Function to call on renderstepped. Orients the character so it is facing towards
			-- the player mouse's position in world space. If character is sitting then the torso
			-- should not track
			local function frame(mousePosition)
				-- Special mobile consideration. We don't want to track if the user was touching a ui
				-- element such as the movement controls. Just return out of function if so to make sure
				-- character doesn't track
				if not mobileShouldTrack then return end
	
				-- Make sure character isn't swiming. If the character is swimming the following code will
				-- not work well; the character will not swim correctly. Besides, who shoots underwater?
				if player.Character.Humanoid:GetState() ~= Enum.HumanoidStateType.Swimming then
					local torso = player.Character.Torso
					local head = player.Character.Head
	
					local toMouse = (mousePosition - head.Position).unit
					local angle = math.acos(toMouse:Dot(Vector3.new(0,1,0)))
	
					local neckAngle = angle
	
					-- Limit how much the head can tilt down. Too far and the head looks unnatural
					if math.deg(neckAngle) > 110 then
						neckAngle = math.rad(110)
					end
					neck.C0 = CFrame.new(0,1,0) * CFrame.Angles(math.pi - neckAngle,math.pi,0)
	
					-- Calculate horizontal rotation
					local arm = player.Character:FindFirstChild("Right Arm")
					local fromArmPos = torso.Position + torso.CFrame:vectorToWorldSpace(Vector3.new(
						torso.Size.X/2 + arm.Size.X/2, torso.Size.Y/2 - arm.Size.Z/2, 0))
					local toMouseArm = ((mousePosition - fromArmPos) * Vector3.new(1,0,1)).unit
					local look = (torso.CFrame.lookVector * Vector3.new(1,0,1)).unit
					local lateralAngle = math.acos(toMouseArm:Dot(look))		
	
					-- Check for rogue math
					if tostring(lateralAngle) == "-1.#IND" then
						lateralAngle = 0
					end		
	
					-- Handle case where character is sitting down
					if player.Character.Humanoid:GetState() == Enum.HumanoidStateType.Seated then			
	
						local cross = torso.CFrame.lookVector:Cross(toMouseArm)
						if lateralAngle > math.pi/2 then
							lateralAngle = math.pi/2
						end
						if cross.Y < 0 then
							lateralAngle = -lateralAngle
						end
					end	
	
					-- Turn shoulder to point to mouse
					shoulder.C0 = CFrame.new(1,0.5,0) * CFrame.Angles(math.pi/2 - angle,math.pi/2 + lateralAngle,0)	
	
					-- If not sitting then aim torso laterally towards mouse
					if not amISitting(player.Character) then
						torso.CFrame = CFrame.new(torso.Position, torso.Position + (Vector3.new(
							mousePosition.X, torso.Position.Y, mousePosition.Z)-torso.Position).unit)
					else
						--print("sitting")		
					end	
				end
			end
	
			-- Function to bind to render stepped if player is on PC
			local function pcFrame()
				frame(mouse.Hit.p)
			end
	
			-- Function to bind to touch moved if player is on mobile
			local function mobileFrame(touch, processed)
				-- Check to see if the touch was on a UI element. If so, we don't want to update anything
				if not processed then
					-- Calculate touch position in world space. Uses Stravant's ScreenSpace Module script
					-- to create a ray from the camera.
					local test = screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y, 1)
					local nearPos = game.Workspace.CurrentCamera.CoordinateFrame:vectorToWorldSpace(screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y, 1))
					nearPos = game.Workspace.CurrentCamera.CoordinateFrame.p - nearPos
					local farPos = screenSpace.ScreenToWorld(touch.Position.X, touch.Position.Y,50) 
					farPos = game.Workspace.CurrentCamera.CoordinateFrame:vectorToWorldSpace(farPos) * -1
					if farPos.magnitude > 900 then
						farPos = farPos.unit * 900
					end
					local ray = Ray.new(nearPos, farPos)
					local part, pos = game.Workspace:FindPartOnRay(ray, player.Character)
	
					-- if a position was found on the ray then update the character's rotation
					if pos then
						frame(pos)
					end
				end
			end
	
			local oldIcon = nil
			-- Function to bind to equip event
			local function equip()
				local torso = player.Character.Torso
	
				-- Setup joint variables
				neck = torso.Neck	
				oldNeckC0 = neck.C0
				shoulder = torso:FindFirstChild("Right Shoulder")
				oldShoulderC0 = shoulder.C0
	
				-- Remember old mouse icon and update current
				oldIcon = mouse.Icon
				mouse.Icon = "rbxassetid:// 2184939409"
	
				-- Bind TouchMoved event if on mobile. Otherwise connect to renderstepped
				if userInputService.TouchEnabled then
					connection = userInputService.TouchMoved:connect(mobileFrame)
				else
					connection = render:connect(pcFrame)
				end
	
				-- Bind TouchStarted and TouchEnded. Used to determine if character should rotate
				-- during touch input
				userInputService.TouchStarted:connect(function(touch, processed)
					mobileShouldTrack = not processed
				end)	
				userInputService.TouchEnded:connect(function(touch, processed)
					mobileShouldTrack = false
				end)
	
				-- Fire server's equip event
				game.ReplicatedStorage.ROBLOX_PistolEquipEvent:FireServer()
	
				-- Bind event for when mouse is clicked to fire server's fire event
				mouse.Button1Down:connect(function()
					game.ReplicatedStorage.ROBLOX_PistolFireEvent:FireServer(mouse.Hit.p)
				end)
	
				-- Bind reload event to mobile button and r key
				contextActionService:BindActionToInputTypes("Reload", function() 
					game.ReplicatedStorage.ROBLOX_PistolReloadEvent:FireServer()		
				end, true, "")
	
				-- If game uses filtering enabled then need to update server while tool is
				-- held by character.
				if workspace.FilteringEnabled then
					while connection do
						wait()
						game.ReplicatedStorage.ROBLOX_PistolUpdateEvent:FireServer(neck.C0, shoulder.C0)
					end
				end
			end
	
			-- Function to bind to Unequip event
			local function unequip()
				if connection then connection:disconnect() end
				contextActionService:UnbindAction("Reload")
				game.ReplicatedStorage.ROBLOX_PistolUnequipEvent:FireServer()
				mouse.Icon = oldIcon
				neck.C0 = oldNeckC0
				shoulder.C0 = oldShoulderC0
			end
	
			-- Bind tool events
			Tool.Equipped:connect(equip)
			Tool.Unequipped:connect(unequip)
		end))
		Script5.Name = "qPerfectionWeld"
		Script5.Parent = Tool0
		table.insert(cors,sandbox(Script5,function()
			-- Created by Quenty (@Quenty, follow me on twitter).
			-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
			-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.
	
	--[[ INSTRUCTIONS
	- Place in the model
	- Make sure model is anchored
	- That's it. It will weld the model and all children. 
	
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
	
	This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
	]]
	
	--[[ DOCUMENTATION
	- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
	- Will work in PBS servers
	- Will work as long as it starts out with the part anchored
	- Stores the relative CFrame as a CFrame value
	- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
	- Utilizes a recursive algorith to find all parts in the model
	- Will reweld on script reparent if the script is initially parented to a tool.
	- Welds as fast as possible
	]]
	
			-- qPerfectionWeld.lua
			-- Created 10/6/2014
			-- Author: Quenty
			-- Version 1.0.3
	
			-- Updated 10/14/2014 - Updated to 1.0.1
			--- Bug fix with existing ROBLOX welds ? Repro by asimo3089
	
			-- Updated 10/14/2014 - Updated to 1.0.2
			--- Fixed bug fix. 
	
			-- Updated 10/14/2014 - Updated to 1.0.3
			--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/
	
			local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).
	
	
			local function CallOnChildren(Instance, FunctionToCall)
				-- Calls a function on each of the children of a certain object, using recursion.  
	
				FunctionToCall(Instance)
	
				for _, Child in next, Instance:GetChildren() do
					CallOnChildren(Child, FunctionToCall)
				end
			end
	
			local function GetNearestParent(Instance, ClassName)
				-- Returns the nearest parent of a certain class, or returns nil
	
				local Ancestor = Instance
				repeat
					Ancestor = Ancestor.Parent
					if Ancestor == nil then
						return nil
					end
				until Ancestor:IsA(ClassName)
	
				return Ancestor
			end
	
			local function GetBricks(StartInstance)
				local List = {}
	
				-- if StartInstance:IsA("BasePart") then
				-- 	List[#List+1] = StartInstance
				-- end
	
				CallOnChildren(StartInstance, function(Item)
					if Item:IsA("BasePart") then
						List[#List+1] = Item;
					end
				end)
	
				return List
			end
	
			local function Modify(Instance, Values)
				-- Modifies an Instance by using a table.  
	
				assert(type(Values) == "table", "Values is not a table");
	
				for Index, Value in next, Values do
					if type(Index) == "number" then
						Value.Parent = Instance
					else
						Instance[Index] = Value
					end
				end
				return Instance
			end
	
			local function Make(ClassType, Properties)
				-- Using a syntax hack to create a nice way to Make new items.  
	
				return Modify(Instance.new(ClassType), Properties)
			end
	
			local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
			local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}
	
			local function HasWheelJoint(Part)
				for _, SurfaceName in pairs(Surfaces) do
					for _, HingSurfaceName in pairs(HingSurfaces) do
						if Part[SurfaceName].Name == HingSurfaceName then
							return true
						end
					end
				end
	
				return false
			end
	
			local function ShouldBreakJoints(Part)
				--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
				--  definitely some edge cases. 
	
				if NEVER_BREAK_JOINTS then
					return false
				end
	
				if HasWheelJoint(Part) then
					return false
				end
	
				local Connected = Part:GetConnectedParts()
	
				if #Connected == 1 then
					return false
				end
	
				for _, Item in pairs(Connected) do
					if HasWheelJoint(Item) then
						return false
					elseif not Item:IsDescendantOf(script.Parent) then
						return false
					end
				end
	
				return true
			end
	
			local function WeldTogether(Part0, Part1, JointType, WeldParent)
				--- Weld's 2 parts together
				-- @param Part0 The first part
				-- @param Part1 The second part (Dependent part most of the time).
				-- @param [JointType] The type of joint. Defaults to weld.
				-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
				-- @return The weld created.
	
				JointType = JointType or "Weld"
				local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
				local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
				Modify(NewWeld, {
					Name = "qCFrameWeldThingy";
					Part0  = Part0;
					Part1  = Part1;
					C0     = CFrame.new();--Part0.CFrame:inverse();
					C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
					Parent = Part1;
				})
	
				if not RelativeValue then
					RelativeValue = Make("CFrameValue", {
						Parent     = Part1;
						Name       = "qRelativeCFrameWeldValue";
						Archivable = true;
						Value      = NewWeld.C1;
					})
				end
	
				return NewWeld
			end
	
			local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
				-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
				-- @param MainPart The part to weld the model to (can be in the model).
				-- @param [JointType] The type of joint. Defaults to weld. 
				-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
				for _, Part in pairs(Parts) do
					if ShouldBreakJoints(Part) then
						Part:BreakJoints()
					end
				end
	
				for _, Part in pairs(Parts) do
					if Part ~= MainPart then
						WeldTogether(MainPart, Part, JointType, MainPart)
					end
				end
	
				if not DoNotUnanchor then
					for _, Part in pairs(Parts) do
						Part.Anchored = false
					end
					MainPart.Anchored = false
				end
			end
	
			local function PerfectionWeld()	
				local Tool = GetNearestParent(script, "Tool")
	
				local Parts = GetBricks(script.Parent)
				local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]
	
				if PrimaryPart then
					WeldParts(Parts, PrimaryPart, "Weld", false)
				else
					warn("qWeld - Unable to weld part")
				end
	
				return Tool
			end
	
			local Tool = PerfectionWeld()
	
	
			if Tool and script.ClassName == "Script" then
				--- Don't bother with local scripts
	
				script.Parent.AncestryChanged:connect(function()
					PerfectionWeld()
				end)
			end
	
			-- Created by Quenty (@Quenty, follow me on twitter).
	
		end))
		LocalScript6.Name = "Animate"
		LocalScript6.Parent = Tool0
		table.insert(cors,sandbox(LocalScript6,function()
			local arms = nil
			local torso = nil
			local welds = {}
			local Tool = script.Parent
			local neck = nil
			local orginalC0 = CFrame.new(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
	
			function Equip(mouse)
				wait(0.01)
				arms = {Tool.Parent:FindFirstChild("Left Arm"), Tool.Parent:FindFirstChild("Right Arm")}
				head = Tool.Parent:FindFirstChild("Head") 
				torso = Tool.Parent:FindFirstChild("Torso")
				if neck == nil then 
					neck = Tool.Parent:FindFirstChild("Torso").Neck
				end 
				if arms ~= nil and torso ~= nil then
					local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
					if sh ~= nil then
						local yes = true
						if yes then
							yes = false
							sh[1].Part1 = nil
							sh[2].Part1 = nil
							local weld1 = Instance.new("Weld")
							weld1.Part0 = head
							weld1.Parent = head
							weld1.Part1 = arms[1]
							welds[1] = weld1
							local weld2 = Instance.new("Weld")
							weld2.Part0 = head
							weld2.Parent = head
							weld2.Part1 = arms[2]
							welds[2] = weld2
							-------------------------here
							weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
							weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
							mouse.Move:connect(function ()
								--local Direction = Tool.Direction.Value 
								local Direction = mouse.Hit.p
								local b = head.Position.Y-Direction.Y
								local dist = (head.Position-Direction).magnitude
								local answer = math.asin(b/dist)
								neck.C0=orginalC0*CFrame.fromEulerAnglesXYZ(answer,0,0)
								wait(0.1)
							end)end
					else
						print("sh")
					end
				else
					print("arms")
				end
			end
	
			function Unequip(mouse)
				if arms ~= nil and torso ~= nil then
					local sh = {torso:FindFirstChild("Left Shoulder"), torso:FindFirstChild("Right Shoulder")}
					if sh ~= nil then
						local yes = true
						if yes then
							yes = false
							neck.C0 = orginalC0
	
							sh[1].Part1 = arms[1]
							sh[2].Part1 = arms[2]
							welds[1].Parent = nil
							welds[2].Parent = nil
						end
					else
						print("sh")
					end
				else
					print("arms")
				end
			end
			Tool.Equipped:connect(Equip)
			Tool.Unequipped:connect(Unequip)
	
			function Animate()
				arms = {Tool.Parent:FindFirstChild("Left Arm"), Tool.Parent:FindFirstChild("Right Arm")}
				if Tool.AnimateValue.Value == "Shoot" then 
					local weld1 = welds[1]
					local weld2 = welds[2]
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
					wait(0.00001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.05, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
					wait(0.00001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.1, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-95), math.rad(-15), 0)
					wait(0.00001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.3, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-110), math.rad(-15), 0)
					wait(0.00001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.35, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-115), math.rad(-15), 0)
					wait(0.00001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
					wait(0.00001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)	
					Tool.AnimateValue.Value = "None"
				end 
				if Tool.AnimateValue.Value == "Reload" then 
					local weld1 = welds[1]
					local weld2 = welds[2]
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-95), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-100), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-105), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-110), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.4, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-115), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.45, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.9, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.5, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 1, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.55, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 1.1, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.57, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 1.2, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.6, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 1.3, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0.6, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-120), math.rad(-15), 0)
					wait(0.0001)
					weld1.C1 = CFrame.new(-0.5+1.5, 0.8, .9)* CFrame.fromEulerAnglesXYZ(math.rad(290), 0, math.rad(-90))
					weld2.C1 = CFrame.new(-1, 0.8, 0.5-1.5) * CFrame.fromEulerAnglesXYZ(math.rad(-90), math.rad(-15), 0)	
					Tool.AnimateValue.Value = "None"
				end 
			end 
	
			Tool.AnimateValue.Changed:connect(Animate)
	
		end))
		Script7.Name = "LineConnect"
		Script7.Parent = Tool0
		Script7.Disabled = true
		table.insert(cors,sandbox(Script7,function()
			wait()
			local check = script.Part2
			local part1 = script.Part1.Value
			local part2 = script.Part2.Value
			local parent = script.Par.Value
			local color = script.Color
			local line = Instance.new("Part")
			line.TopSurface = 0
			line.BottomSurface = 0
			line.Reflectance = .5
			line.Name = "Laser"
			line.Transparency = 0.6
			line.Locked = true
			line.CanCollide = false
			line.Anchored = true
			line.formFactor = 0
			line.Size = Vector3.new(0.4,0.4,1)
			local mesh = Instance.new("BlockMesh")
			mesh.Parent = line
			while true do
				if (check.Value==nil) then break end
				if (part1==nil or part2==nil or parent==nil) then break end
				if (part1.Parent==nil or part2.Parent==nil) then break end
				if (parent.Parent==nil) then break end
				local lv = CFrame.new(part1.Position,part2.Position)
				local dist = (part1.Position-part2.Position).magnitude
				line.Parent = parent
				line.Material = "Neon"
				line.BrickColor = color.Value.BrickColor
				line.Reflectance = color.Value.Reflectance
				line.Transparency = "0.2"
				line.CFrame = CFrame.new(part1.Position+lv.lookVector*dist/2)
				line.CFrame = CFrame.new(line.Position,part2.Position)
				mesh.Scale = Vector3.new(.25,.25,dist)
				wait()
			end
			line:remove()
			script:remove() 
		end))
		LocalScript8.Name = "MainScript"
		LocalScript8.Parent = Tool0
		table.insert(cors,sandbox(LocalScript8,function()
			--Physics gun created by Killersoldier45
			wait() 
			tool = script.Parent
			lineconnect = tool.LineConnect
			object = nil
			mousedown = false
			found = false
			BP = Instance.new("BodyPosition")
			BP.maxForce = Vector3.new(math.huge*math.huge,math.huge*math.huge,math.huge*math.huge) --pwns everyone elses bodyposition
			BP.P = BP.P*10 --faster movement. less bounceback.
			dist = nil
			point = Instance.new("Part")
			point.Locked = true
			point.Anchored = true
			point.formFactor = 0
			point.Shape = 0
			point.Material = 'Neon'
			point.BrickColor = BrickColor.new("Toothpaste")
			point.Size = Vector3.new(1,1,1)
			point.CanCollide = false
			local mesh = Instance.new("SpecialMesh")
			mesh.MeshType = "Sphere"
			mesh.Scale = Vector3.new(.2,.2,.2)
			mesh.Parent = point
			handle = tool.Shoot
			front = tool.Shoot
			color = tool.Shoot
			objval = nil
			local hooked = false 
			local hookBP = BP:clone() 
			hookBP.maxForce = Vector3.new(30000,30000,30000) 
	
			function LineConnect(part1,part2,parent)
				local p1 = Instance.new("ObjectValue")
				p1.Value = part1
				p1.Name = "Part1"
				local p2 = Instance.new("ObjectValue")
				p2.Value = part2
				p2.Name = "Part2"
				local par = Instance.new("ObjectValue")
				par.Value = parent
				par.Name = "Par"
				local col = Instance.new("ObjectValue")
				col.Value = color
				col.Name = "Color"
				local s = lineconnect:clone()
				s.Disabled = false
				p1.Parent = s
				p2.Parent = s
				par.Parent = s
				col.Parent = s
				s.Parent = workspace
				if (part2==object) then
					objval = p2
				end
			end
	
			function onButton1Down(mouse)
				if (mousedown==true) then return end
				mousedown = true
				coroutine.resume(coroutine.create(function()
					local p = point:clone()
					p.Parent = tool
					LineConnect(front,p,workspace)
					while (mousedown==true) do
						p.Parent = tool
						if (object==nil) then
							if (mouse.Target==nil) then
								local lv = CFrame.new(front.Position,mouse.Hit.p)
								p.CFrame = CFrame.new(front.Position+(lv.lookVector*1000))
							else
								p.CFrame = CFrame.new(mouse.Hit.p)
							end
						else
							LineConnect(front,object,workspace)
							break
						end
						wait()
					end
					p:remove()
				end))
				while (mousedown==true) do
					if (mouse.Target~=nil) then
						local t = mouse.Target
						if (t.Anchored==false) then
							object = t
							dist = (object.Position-front.Position).magnitude
							break
						end
					end
					wait()
				end
				while (mousedown==true) do
					if (object.Parent==nil) then break end
					local lv = CFrame.new(front.Position,mouse.Hit.p)
					BP.Parent = object
					BP.position = front.Position+lv.lookVector*dist
					wait()
				end
				BP:remove()
				object = nil
				objval.Value = nil
			end
	
			function onKeyDown(key,mouse) 
				local key = key:lower() 
				local yesh = false 
				if (key=="q") then 
					if (dist>=5) then 
						dist = dist-5 
					end 
				end 
				if key == "t" then 
					if (object==nil) then return end 
					for _,v in pairs(object:children()) do 
						if v.className == "BodyGyro" then 
							return nil 
						end 
					end 
					BG = Instance.new("BodyGyro") 
					BG.maxTorque = Vector3.new(math.huge,math.huge,math.huge) 
					BG.cframe = CFrame.new(object.CFrame.p) 
					BG.Parent = object 
					repeat wait() until(object.CFrame == CFrame.new(object.CFrame.p)) 
					BG.Parent = nil 
					if (object==nil) then return end 
					for _,v in pairs(object:children()) do 
						if v.className == "BodyGyro" then 
							v.Parent = nil 
						end 
					end 
					object.Velocity = Vector3.new(0,0,0) 
					object.RotVelocity = Vector3.new(0,0,0) 
				end 
				if (key=="e") then
					dist = dist+5
				end
				if (string.byte(key)==27) then 
					if (object==nil) then return end
					local e = Instance.new("Explosion")
					e.Parent = workspace
					e.Position = object.Position
					color.BrickColor = BrickColor.Black()
					point.BrickColor = BrickColor.White() 
					wait(.48)
					color.BrickColor = BrickColor.White() 
					point.BrickColor = BrickColor.Black() 
				end
				if (key=="") then 
					if not hooked then 
						if (object==nil) then return end 
						hooked = true 
						hookBP.position = object.Position 
						if tool.Parent:findFirstChild("Torso") then 
							hookBP.Parent = tool.Parent.Torso 
							if dist ~= (object.Size.x+object.Size.y+object.Size.z)+5 then 
								dist = (object.Size.x+object.Size.y+object.Size.z)+5 
							end 
						end 
					else 
						hooked = false 
						hookBP.Parent = nil 
					end 
				end 
				if (key=="r") then 
					if (object==nil) then return end 
					color.BrickColor = BrickColor.new("Toothpaste") 
					point.BrickColor = BrickColor.new("Toothpaste") 
					object.Parent = nil 
					wait(.48) 
					color.BrickColor = BrickColor.new("Toothpaste")
					point.BrickColor = BrickColor.new("Toothpaste")
				end 
				if (key=="x") then 
					if (object==nil) then return end 
					local New = object:clone() 
					New.Parent = object.Parent 
					for _,v in pairs(New:children()) do 
						if v.className == "BodyPosition" or v.className == "BodyGyro" then 
							v.Parent = nil 
						end 
					end 
					object = New 
					mousedown = false 
					mousedown = true 
					LineConnect(front,object,workspace) 
					while (mousedown==true) do
						if (object.Parent==nil) then break end
						local lv = CFrame.new(front.Position,mouse.Hit.p)
						BP.Parent = object
						BP.position = front.Position+lv.lookVector*dist
						wait()
					end
					BP:remove()
					object = nil
					objval.Value = nil
				end 
				if (key=="c") then 
					local Cube = Instance.new("Part") 
					Cube.Locked = true 
					Cube.Size = Vector3.new(4,4,4) 
					Cube.formFactor = 0 
					Cube.TopSurface = 0 
					Cube.BottomSurface = 0 
					Cube.Name = "WeightedStorageCube" 
					Cube.Parent = workspace 
					Cube.CFrame = CFrame.new(mouse.Hit.p) + Vector3.new(0,2,0) 
					for i = 0,5 do 
						local Decal = Instance.new("Decal") 
						Decal.Texture = "http://www.roblox.com/asset/?id=2662260" 
						Decal.Face = i 
						Decal.Name = "WeightedStorageCubeDecal" 
						Decal.Parent = Cube 
					end 
				end 
				if (key=="") then 
					if dist ~= 15 then 
						dist = 15 
					end 
				end 
			end
	
			function onEquipped(mouse)
				keymouse = mouse
				local char = tool.Parent
				human = char.Humanoid
				human.Changed:connect(function() if (human.Health==0) then mousedown = false BP:remove() point:remove() tool:remove() end end)
				mouse.Button1Down:connect(function() onButton1Down(mouse) end)
				mouse.Button1Up:connect(function() mousedown = false end)
				mouse.KeyDown:connect(function(key) onKeyDown(key,mouse) end)
				mouse.Icon = "rbxassetid://2184939409"
			end
	
			tool.Equipped:connect(onEquipped)
		end))
		Part9.Name = "GlowPart"
		Part9.Parent = Tool0
		Part9.Material = Enum.Material.Neon
		Part9.BrickColor = BrickColor.new("Cyan")
		Part9.Transparency = 0.5
		Part9.Rotation = Vector3.new(0, -89.5899963, 0)
		Part9.Shape = Enum.PartType.Cylinder
		Part9.Size = Vector3.new(1.20000005, 0.649999976, 2)
		Part9.CFrame = CFrame.new(-54.8191681, 0.773548007, -0.0522949994, 0.00736002205, 4.68389771e-11, -0.999974668, 4.72937245e-11, 1, 1.41590961e-10, 0.999974668, 5.09317033e-11, 0.00736002252)
		Part9.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		Part9.Position = Vector3.new(-54.8191681, 0.773548007, -0.0522949994)
		Part9.Orientation = Vector3.new(0, -89.5799942, 0)
		Part9.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		Script10.Name = "Glow Script"
		Script10.Parent = Part9
		table.insert(cors,sandbox(Script10,function()
			while true do
				wait(0.05)
				script.Parent.Transparency = .5
				wait(0.05)
				script.Parent.Transparency = .6
				wait(0.05)
				script.Parent.Transparency = .7
				wait(0.05)
				script.Parent.Transparency = .8
				wait(0.05)
				script.Parent.Transparency = .9
				wait(0.05)
				script.Parent.Transparency = .8
				wait(0.05)
				script.Parent.Transparency = .7
				wait(0.05)
				script.Parent.Transparency = .6
				wait(0.05)
				script.Parent.Transparency = .5
			end
	
		end))
		Part11.Name = "GlowPart"
		Part11.Parent = Tool0
		Part11.Material = Enum.Material.Neon
		Part11.BrickColor = BrickColor.new("Cyan")
		Part11.Transparency = 0.5
		Part11.Rotation = Vector3.new(-89.3799973, -55.7399979, -89.25)
		Part11.Size = Vector3.new(0.280000001, 0.25999999, 0.200000003)
		Part11.CFrame = CFrame.new(-54.9808807, 0.99843204, 0.799362957, 0.00736002205, 0.562958956, -0.826454222, 4.72937245e-11, 0.826475084, 0.56297338, 0.999974668, -0.00414349511, 0.00608287565)
		Part11.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		Part11.Position = Vector3.new(-54.9808807, 0.99843204, 0.799362957)
		Part11.Orientation = Vector3.new(-34.2599983, -89.5799942, 0)
		Part11.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		Script12.Name = "Glow Script"
		Script12.Parent = Part11
		table.insert(cors,sandbox(Script12,function()
			while true do
				wait(0.05)
				script.Parent.Transparency = .5
				wait(0.05)
				script.Parent.Transparency = .6
				wait(0.05)
				script.Parent.Transparency = .7
				wait(0.05)
				script.Parent.Transparency = .8
				wait(0.05)
				script.Parent.Transparency = .9
				wait(0.05)
				script.Parent.Transparency = .8
				wait(0.05)
				script.Parent.Transparency = .7
				wait(0.05)
				script.Parent.Transparency = .6
				wait(0.05)
				script.Parent.Transparency = .5
			end
	
		end))
		Part13.Name = "GlowPart"
		Part13.Parent = Tool0
		Part13.Material = Enum.Material.Neon
		Part13.BrickColor = BrickColor.new("Cyan")
		Part13.Transparency = 0.5
		Part13.Rotation = Vector3.new(95.1500015, -53.8199997, 98.0799942)
		Part13.Size = Vector3.new(0.280000001, 0.25999999, 0.200000003)
		Part13.CFrame = CFrame.new(-54.5909271, 0.978429973, 0.799362957, -0.0830051303, -0.584483683, -0.807150841, 0.0241250042, 0.808528602, -0.58796227, 0.996258855, -0.0682764053, -0.0530113392)
		Part13.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		Part13.Position = Vector3.new(-54.5909271, 0.978429973, 0.799362957)
		Part13.Orientation = Vector3.new(36.0099983, -93.7599945, 1.70999992)
		Part13.Color = Color3.new(0.0156863, 0.686275, 0.92549)
		Script14.Name = "Glow Script"
		Script14.Parent = Part13
		table.insert(cors,sandbox(Script14,function()
			while true do
				wait(0.05)
				script.Parent.Transparency = .5
				wait(0.05)
				script.Parent.Transparency = .6
				wait(0.05)
				script.Parent.Transparency = .7
				wait(0.05)
				script.Parent.Transparency = .8
				wait(0.05)
				script.Parent.Transparency = .9
				wait(0.05)
				script.Parent.Transparency = .8
				wait(0.05)
				script.Parent.Transparency = .7
				wait(0.05)
				script.Parent.Transparency = .6
				wait(0.05)
				script.Parent.Transparency = .5
			end
	
		end))
		for i,v in pairs(mas:GetChildren()) do
			v.Parent = game:GetService("Players").LocalPlayer.Backpack
			pcall(function() v:MakeJoints() end)
		end
		mas:Destroy()
		for i,v in pairs(cors) do
			spawn(function()
				pcall(v)
			end)
		end
	end)
end
coroutine.wrap(YIBDDCZ_fake_script)()
-- Page3Button.LocalScript is disabled.
local function YPNDE_fake_script() -- Pacifist.LocalScript 
	local script = Instance.new('LocalScript', Pacifist)

	script.Parent.MouseButton1Click:Connect(function()
		--[[Pacifist class created by Brannon1964802.]]--
		Bypass = "death"
		loadstring(game:GetObjects("rbxassetid://5325226148")[1].Source)()
		for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
			if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then 
				game:GetService("RunService").Heartbeat:connect(function()
					v.Velocity = Vector3.new(0,30,0)
					wait(0.5)
				end)
			end
		end
		local p = game.Players.LocalPlayer
		local char = p.Character
		local mouse = p:GetMouse()
		local larm = char["Left Arm"]
		local rarm = char["Right Arm"]
		local lleg = char["Left Leg"]
		local rleg = char["Right Leg"]
		local hed = char.Head
		local torso = char.Torso
		local hum = char.Humanoid
		local cam = game.Workspace.CurrentCamera
		local root = char.HumanoidRootPart
		for i,v in pairs (char:GetChildren()) do
			if v:IsA("Accessory") then
				v.Handle.Massless = true
				v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
			end
		end
		hed.Massless = true
		hed.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
		torso.Massless = true
		torso.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
		rarm.Massless = true
		rarm.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
		larm.Massless = true
		larm.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
		lleg.Massless = true
		lleg.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
		rleg.Massless = true
		rleg.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
		root.Massless = true
		root.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
		warn("Netless Activated!")
	
		Player=game:GetService("Players").LocalPlayer
		Character=game.Workspace.non 
		PlayerGui=Player.PlayerGui
		Backpack=Player.Backpack 
		Torso=Character.Torso 
		Head=Character.Head 
		Humanoid=Character.Humanoid
		m=Instance.new('Model',Character)
		LeftArm=Character["Left Arm"] 
		LeftLeg=Character["Left Leg"] 
		RightArm=Character["Right Arm"] 
		RightLeg=Character["Right Leg"] 
		LS=Torso["Left Shoulder"] 
		LH=Torso["Left Hip"] 
		RS=Torso["Right Shoulder"] 
		RH=Torso["Right Hip"] 
		Face = Head.face
		Neck=Torso.Neck
		--it=Instance.new
		attacktype=1
		vt=Vector3.new
		cf=CFrame.new
		euler=CFrame.fromEulerAnglesXYZ
		angles=CFrame.Angles
		cloaked=false
		necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
		LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
		LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
		RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
		RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
		RootPart=Character.HumanoidRootPart
		RootJoint=RootPart.RootJoint
		RootCF=euler(-1.57,0,3.14)
		attack = false 
		attackdebounce = false 
		deb=false
		equipped=true
		hand=false
		MMouse=nil
		combo=0
		mana=0
		trispeed=.2
		attackmode='none'
		local idle=0
		local Anim="Idle"
		local gun=false
		local shoot=false
		player=nil 
		mana=0
	
		local defensevalue = .3
		local speedvalue = 1
		local damagevalue = 1
		local cf = CFrame.new-- make things easier :)
		local mr = math.rad
		local angles = CFrame.Angles
		local ud = UDim2.new
		local c3 = Color3.new
	
		local stats=Instance.new('Folder',Character)
		stats.Name='Stats'
		local block=Instance.new('BoolValue',stats)
		block.Name='Block'
		block.Value=false
		local stun=Instance.new('BoolValue',stats)
		stun.Name='Stun'
		stun.Value=false
		local defense=Instance.new('NumberValue',stats)
		defense.Name='Defence'
		defense.Value=defensevalue
		local speed=Instance.new('NumberValue',stats)
		speed.Name='Speed'
		speed.Value=speedvalue
		local damagea=Instance.new('NumberValue',stats)
		damagea.Name='Damage'
		damagea.Value=damagevalue
	
		Humanoid = Character.Humanoid
		if Humanoid:FindFirstChild("Animator")then
			Humanoid:FindFirstChild("Animator"):Destroy()
		end
	
		Humanoid.WalkSpeed = 10
	
	--[[music = Instance.new("Sound", Torso)
	music.SoundId = "http://www.roblox.com/asset/?id=179604943"
	music.Volume = 0.5
	music.Looped = true
	wait(0.1)
	music:Play()]]--
	
		Colorpart1 = Torso.BrickColor.r
		Colorpart2 = Torso.BrickColor.g
		Colorpart3 = Torso.BrickColor.b
	
		CloakEffectLight2 = Instance.new("PointLight", Torso)
		CloakEffectLight2.Color = Color3.new(Colorpart1, Colorpart2, Colorpart3)
		CloakEffectLight2.Range = 7.5
		CloakEffectLight2.Brightness = 7.5
		CloakEffectLight2.Enabled = true
	
		mouse=Player:GetMouse()
		--save shoulders 
		RSH, LSH=nil, nil 
		--welds 
		RW, LW=Instance.new("Motor"), Instance.new("Motor") 
		RW.Name="Right Shoulder" LW.Name="Left Shoulder"
		LH=Torso["Left Hip"]
		RH=Torso["Right Hip"]
		TorsoColor=Torso.BrickColor
		function NoOutline(Part)
			Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
		end
		player=Player 
		ch=Character
		RSH=ch.Torso["Right Shoulder"] 
		LSH=ch.Torso["Left Shoulder"] 
		-- 
		RSH.Parent=nil 
		LSH.Parent=nil 
		-- 
		RW.Name="Right Shoulder"
		RW.Part0=ch.Torso 
		RW.C0=cf(1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.3, 0, -0.5) 
		RW.C1=cf(0, 0.5, 0) 
		RW.Part1=ch["Right Arm"] 
		RW.Parent=ch.Torso 
		-- 
		LW.Name="Left Shoulder"
		LW.Part0=ch.Torso 
		LW.C0=cf(-1.5, 0.5, 0) --* CFrame.fromEulerAnglesXYZ(1.7, 0, 0.8) 
		LW.C1=cf(0, 0.5, 0) 
		LW.Part1=ch["Left Arm"] 
		LW.Parent=ch.Torso 
	
		local function weldBetween(a, b)
			local weldd = Instance.new("ManualWeld")
			weldd.Part0 = a
			weldd.Part1 = b
			weldd.C0 = CFrame.new()
			weldd.C1 = b.CFrame:inverse() * a.CFrame
			weldd.Parent = a
			return weldd
		end
	
		fat = Instance.new("BindableEvent", script)
		fat.Name = "Heartbeat"
	
		script:WaitForChild("Heartbeat")
	
		frame = 1 / 30
		tf = 0
		allowframeloss = false --if set to true will fire every frame it possibly can. This will result in multiple events happening at the same time whenever delta returns frame*2 or greater.
		tossremainder = false --if set to true t will be set to 0 after Fire()-ing.
		lastframe = tick()
		script.Heartbeat:Fire() --ayy lmao
	
		game:GetService("RunService").Heartbeat:connect(function(s, p) --herp derp
			tf = tf + s
			if tf >= frame then
				if allowframeloss then
					script.Heartbeat:Fire()
					lastframe = tick()
				else
					--print("FIRED "..math.floor(t/frame).." FRAME(S)","REMAINDER "..(t - frame*(math.floor(t/frame))))
					for i = 1, math.floor(tf / frame) do
						script.Heartbeat:Fire()
					end
					lastframe = tick()
				end
				if tossremainder then
					tf = 0
				else
					tf = tf - frame * math.floor(tf / frame)
				end
			end
		end)
	
		--To use: fat.Event:fat.Event:wait() or fat.Event:connect(function() asdcode end)
	
		local function CFrameFromTopBack(at, top, back)
			local right = top:Cross(back)
			return CFrame.new(at.x, at.y, at.z,
				right.x, top.x, back.x,
				right.y, top.y, back.y,
				right.z, top.z, back.z)
		end
	
		function Triangle(a, b, c)
			local edg1 = (c-a):Dot((b-a).unit)
			local edg2 = (a-b):Dot((c-b).unit)
			local edg3 = (b-c):Dot((a-c).unit)
			if edg1 <= (b-a).magnitude and edg1 >= 0 then
				a, b, c = a, b, c
			elseif edg2 <= (c-b).magnitude and edg2 >= 0 then
				a, b, c = b, c, a
			elseif edg3 <= (a-c).magnitude and edg3 >= 0 then
				a, b, c = c, a, b
			else
				assert(false, "unreachable")
			end
	
			local len1 = (c-a):Dot((b-a).unit)
			local len2 = (b-a).magnitude - len1
			local width = (a + (b-a).unit*len1 - c).magnitude
	
			local maincf = CFrameFromTopBack(a, (b-a):Cross(c-b).unit, -(b-a).unit)
	
			local list = {}
	
			local TrailColor = ("Dark grey")
	
			if len1 > 0.01 then
				local w1 = Instance.new('WedgePart', m)
				game:GetService("Debris"):AddItem(w1,5)
				w1.Material = "SmoothPlastic"
				w1.FormFactor = 'Custom'
				w1.BrickColor = BrickColor.new(TrailColor)
				w1.Transparency = 0
				w1.Reflectance = 0
				w1.Material = "SmoothPlastic"
				w1.CanCollide = false
				NoOutline(w1)
				local sz = Vector3.new(0.2, width, len1)
				w1.Size = sz
				local sp = Instance.new("SpecialMesh",w1)
				sp.MeshType = "Wedge"
				sp.Scale = Vector3.new(0,1,1) * sz/w1.Size
				w1:BreakJoints()
				w1.Anchored = true
				w1.Parent = workspace
				w1.Transparency = 0.7
				table.insert(Effects,{w1,"Disappear",.01})
				w1.CFrame = maincf*CFrame.Angles(math.pi,0,math.pi/2)*CFrame.new(0,width/2,len1/2)
				table.insert(list,w1)
			end
	
			if len2 > 0.01 then
				local w2 = Instance.new('WedgePart', m)
				game:GetService("Debris"):AddItem(w2,5)
				w2.Material = "SmoothPlastic"
				w2.FormFactor = 'Custom'
				w2.BrickColor = BrickColor.new(TrailColor)
				w2.Transparency = 0
				w2.Reflectance = 0
				w2.Material = "SmoothPlastic"
				w2.CanCollide = false
				NoOutline(w2)
				local sz = Vector3.new(0.2, width, len2)
				w2.Size = sz
				local sp = Instance.new("SpecialMesh",w2)
				sp.MeshType = "Wedge"
				sp.Scale = Vector3.new(0,1,1) * sz/w2.Size
				w2:BreakJoints()
				w2.Anchored = true
				w2.Parent = workspace
				w2.Transparency = 0.7
				table.insert(Effects,{w2,"Disappear",.01})
				w2.CFrame = maincf*CFrame.Angles(math.pi,math.pi,-math.pi/2)*CFrame.new(0,width/2,-len1 - len2/2)
				table.insert(list,w2)
			end
			return unpack(list)
		end
	
		function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
			return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
		end 	
	
		function clerp(a,b,t) 
			local qa = {QuaternionFromCFrame(a)}
			local qb = {QuaternionFromCFrame(b)} 
			local ax, ay, az = a.x, a.y, a.z 
			local bx, by, bz = b.x, b.y, b.z
			local _t = 1-t
			return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
		end
	
		function QuaternionFromCFrame(cf) 
			local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
			local trace = m00 + m11 + m22 
			if trace > 0 then 
				local s = math.sqrt(1 + trace) 
				local recip = 0.5/s 
				return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
			else 
				local i = 0 
				if m11 > m00 then
					i = 1
				end
				if m22 > (i == 0 and m00 or m11) then 
					i = 2 
				end 
				if i == 0 then 
					local s = math.sqrt(m00-m11-m22+1) 
					local recip = 0.5/s 
					return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
				elseif i == 1 then 
					local s = math.sqrt(m11-m22-m00+1) 
					local recip = 0.5/s 
					return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
				elseif i == 2 then 
					local s = math.sqrt(m22-m00-m11+1) 
					local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
				end 
			end 
		end
	
		function QuaternionToCFrame(px, py, pz, x, y, z, w) 
			local xs, ys, zs = x + x, y + y, z + z 
			local wx, wy, wz = w*xs, w*ys, w*zs 
			local xx = x*xs 
			local xy = x*ys 
			local xz = x*zs 
			local yy = y*ys 
			local yz = y*zs 
			local zz = z*zs 
			return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
		end
	
		function QuaternionSlerp(a, b, t) 
			local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
			local startInterp, finishInterp; 
			if cosTheta >= 0.0001 then 
				if (1 - cosTheta) > 0.0001 then 
					local theta = math.acos(cosTheta) 
					local invSinTheta = 1/math.sin(theta) 
					startInterp = math.sin((1-t)*theta)*invSinTheta 
					finishInterp = math.sin(t*theta)*invSinTheta  
				else 
					startInterp = 1-t 
					finishInterp = t 
				end 
			else 
				if (1+cosTheta) > 0.0001 then 
					local theta = math.acos(-cosTheta) 
					local invSinTheta = 1/math.sin(theta) 
					startInterp = math.sin((t-1)*theta)*invSinTheta 
					finishInterp = math.sin(t*theta)*invSinTheta 
				else 
					startInterp = t-1 
					finishInterp = t 
				end 
			end 
			return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
		end
	
		sitting=false
		resting=false
		meditating=false
		sprint=false
	
		mouse.Button1Down:connect(function()
		end)
		print'Only instinct left is survival.'
		mouse.KeyDown:connect(function(k)
			k=k:lower()
			if k=='z' and attack==false and resting==false and sprint==false and meditating==false then
				attack=true
				if sitting==false then
					sitting=true
					Humanoid.WalkSpeed = 0
					for i=0,1,0.04 do
						fat.Event:wait()
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.25)*angles(math.rad(0),math.rad(15),math.rad(0)),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(30)),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(20)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.3,0)*angles(math.rad(15),math.rad(0),math.rad(-25)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-60),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-0.75,0.25,-1)*angles(math.rad(-15),math.rad(-90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(0)),0.15)
					end
				elseif sitting==true then
					sitting=false
					for i=0,1,0.04 do
						fat.Event:wait()
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.25)*angles(math.rad(0),math.rad(15),math.rad(0)),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(30)),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(20)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.3,0)*angles(math.rad(15),math.rad(0),math.rad(-25)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-60),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-0.75,0.25,-1)*angles(math.rad(-15),math.rad(-90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(0)),0.15)
					end
					Humanoid.WalkSpeed = 10
				end
				attack=false
			end
			if k=='x' and attack==false and sitting==false and sprint==false and meditating==false then
				attack=true
				if resting==false then
					resting=true
					Humanoid.WalkSpeed = 0
					for i=0,1,0.04 do
						fat.Event:wait()
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.05)*angles(math.rad(0),math.rad(15),math.rad(0)),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(30)),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(20)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.1,0)*angles(math.rad(15),math.rad(0),math.rad(-25)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-40),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-0.75,0.05,-1)*angles(math.rad(-15),math.rad(-90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(0)),0.15)
					end
				elseif resting==true then
					resting=false
					for i=0,1,0.04 do
						fat.Event:wait()
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.05)*angles(math.rad(0),math.rad(15),math.rad(0)),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(30)),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(20)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.1,0)*angles(math.rad(15),math.rad(0),math.rad(-25)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-40),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-0.75,0.05,-1)*angles(math.rad(-15),math.rad(-90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(0)),0.15)
					end
					Humanoid.WalkSpeed = 10
				end
				attack=false
			end
			if k=='c' and attack==false and sitting==false and resting==false and sprint==false then
				attack=true
				if meditating==false then
					meditating=true
					Humanoid.WalkSpeed = 0
					for i=0,1,0.04 do
						fat.Event:wait()
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.05)*angles(math.rad(0),math.rad(15),math.rad(0)),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(30)),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(20)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.1,0)*angles(math.rad(15),math.rad(0),math.rad(-25)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-40),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-0.75,0.05,-1)*angles(math.rad(-15),math.rad(-90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(0)),0.15)
					end
				elseif meditating==true then
					meditating=false
					for i=0,1,0.04 do
						fat.Event:wait()
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.05)*angles(math.rad(0),math.rad(15),math.rad(0)),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(20),math.rad(0),math.rad(30)),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(20)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.1,0)*angles(math.rad(15),math.rad(0),math.rad(-25)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-40),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-0.75,0.05,-1)*angles(math.rad(-15),math.rad(-90),math.rad(0))*angles(math.rad(-15),math.rad(0),math.rad(0)),0.15)
					end
					Humanoid.WalkSpeed = 10
				end
				attack=false
			end
			if k=='e' and attack==false and resting==false and sitting==false and meditating==false and sprint==false then
				sprint=true
				Humanoid.WalkSpeed = 16
			end
		end)
	
		mouse.KeyUp:connect(function(k)
			if k=='e' and attack==false and resting==false and sitting==false and meditating==false and sprint==true then
				sprint=false
				Humanoid.WalkSpeed = 10
			end
		end)
	
		local sine = 0
		local change = 1
		local val = 0
	
		fat.Event:connect(function()
			sine = sine + change
			local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
			local velderp=RootPart.Velocity.y
			hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
			if equipped==true or equipped==false then
				if attack==false then
					idle=idle+1
				else
					idle=0
				end
				if idle>=500 then
					if attack==false then
						--Sheath()
					end
				end
				if RootPart.Velocity.y > 1 and hitfloor==nil then 
					Anim="Jump"
					if attack==false then
						change=1
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(-10),math.rad(0),math.rad(0)),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(20)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(-20),math.rad(0),math.rad(-20)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(-20),math.rad(90),math.rad(0))*angles(math.rad(-10),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-20),math.rad(-90),math.rad(0))*angles(math.rad(-10),math.rad(0),math.rad(0)),0.15)
					end
				elseif RootPart.Velocity.y < -1 and hitfloor==nil then 
					Anim="Fall"
					if attack==false then
						change=1
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,0)*angles(math.rad(5),math.rad(0),math.rad(0)),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0)),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(10)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(10),math.rad(0),math.rad(-10)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-1,0)*angles(math.rad(10),math.rad(90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-1,-1,0)*angles(math.rad(-10),math.rad(-90),math.rad(0))*angles(math.rad(-5),math.rad(0),math.rad(0)),0.15)
					end
				elseif torvel<1 and hitfloor~=nil then
					Anim="Idle"
					if attack==false and sitting==false and resting==false and meditating==false then
						change=1
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/30))*angles(math.rad(-2.5*math.cos(sine/30)),math.rad(0),math.rad(0)),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(-5*math.cos(sine/30))+ -math.sin(sine/30)/15,math.rad(0),math.rad(0)),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.55+0.05*math.cos(sine/30)+ -math.sin(sine/30)/40,0)*angles(math.rad(5-2.5*math.cos(sine/30)),math.rad(0),math.rad(10+5*math.cos(sine/30))+ math.sin(sine/30)/20),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.55+0.05*math.cos(sine/30)+ -math.sin(sine/30)/40,0)*angles(math.rad(5-2.5*math.cos(sine/30)),math.rad(0),math.rad(-10-5*math.cos(sine/30))+ -math.sin(sine/30)/20),0.15)
						RH.C0=clerp(RH.C0,cf(1,-0.9-0.1*math.cos(sine/30),0.025*math.cos(sine/30))*angles(math.rad(-2.5*math.cos(sine/30)),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-1,-0.9-0.1*math.cos(sine/30),0.025*math.cos(sine/30))*angles(math.rad(-2.5*math.cos(sine/30)),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
					else
						if attack==false and sitting==true and resting==false and meditating==false then
							change=1
							RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.9)*angles(math.rad(-45-2.5*math.cos(sine/30)),math.rad(0),math.rad(0)),0.15)
							Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(-5*math.cos(sine/30))+ -math.sin(sine/30)/15,math.rad(0),math.rad(0)),0.15)
							RW.C0=clerp(RW.C0,CFrame.new(1.5,0.45,0)*angles(math.rad(-45-2.5*math.cos(sine/30)),math.rad(0),math.rad(10)),0.15)
							LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.45,0)*angles(math.rad(-45-2.5*math.cos(sine/30)),math.rad(0),math.rad(-10)),0.15)
							RH.C0=clerp(RH.C0,cf(1,-1,0.025*math.cos(sine/30))*angles(math.rad(45-2.5*math.cos(sine/30)),math.rad(90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
							LH.C0=clerp(LH.C0,cf(-1,-1,0.025*math.cos(sine/30))*angles(math.rad(45-2.5*math.cos(sine/30)),math.rad(-90),math.rad(0))*angles(math.rad(-2.5),math.rad(0),math.rad(0)),0.15)
						else
							if attack==false and sitting==false and resting==true and meditating==false then
								change=1
								RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-2.3)*angles(math.rad(-80-1*math.cos(sine/30)),math.rad(0),math.rad(0)),0.15)
								Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(5-1*math.cos(sine/30))+ -math.sin(sine/30)/15,math.rad(0),math.rad(0)),0.15)
								RW.C0=clerp(RW.C0,CFrame.new(1,0.75,0.1)*angles(math.rad(215-1*math.cos(sine/30)),math.rad(0),math.rad(-45)),0.15)
								LW.C0=clerp(LW.C0,CFrame.new(-1,0.75,0.1)*angles(math.rad(200-1*math.cos(sine/30)),math.rad(0),math.rad(45)),0.15)
								RH.C0=clerp(RH.C0,cf(1,-1,0.025*math.cos(sine/30))*angles(math.rad(25-1*math.cos(sine/30)),math.rad(90),math.rad(0))*angles(math.rad(20),math.rad(0),math.rad(0)),0.15)
								LH.C0=clerp(LH.C0,cf(-1,-1,0.025*math.cos(sine/30))*angles(math.rad(10-1*math.cos(sine/30)),math.rad(-90),math.rad(0))*angles(math.rad(20),math.rad(0),math.rad(0)),0.15)
							else
								if attack==false and sitting==false and resting==false and meditating==true then
									change=1
									RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-1.9)*angles(math.rad(10-1*math.cos(sine/30)),math.rad(0),math.rad(0)),0.15)
									Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0)*angles(math.rad(10-1*math.cos(sine/30))+ -math.sin(sine/30)/15,math.rad(0),math.rad(0)),0.15)
									RW.C0=clerp(RW.C0,CFrame.new(1.25,0.5,-0.5)*angles(math.rad(0),math.rad(165),math.rad(90)),0.15)
									LW.C0=clerp(LW.C0,CFrame.new(-1.25,0.5,-0.5)*angles(math.rad(0),math.rad(-165),math.rad(-90)),0.15)
									RH.C0=clerp(RH.C0,cf(1,-1,0.1)*angles(math.rad(-30),math.rad(75),math.rad(0))*angles(math.rad(80),math.rad(0),math.rad(0)),0.15)
									LH.C0=clerp(LH.C0,cf(-1,-1,0.1)*angles(math.rad(-30),math.rad(-75),math.rad(0))*angles(math.rad(80),math.rad(0),math.rad(0)),0.15)
								end
							end
						end
					end
				elseif torvel>2 and torvel<22 and hitfloor~=nil then
					Anim="Walk"
					if attack==false and sprint==false then
						change=0.5
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.175+0.025*math.cos(sine/3.5)+ -math.sin(sine/3.5)/7)*angles(math.rad(5-2.5*math.cos(sine/3.5)),math.rad(0),math.rad(10*math.cos(sine/7))),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0+0.025*math.cos(sine/3.5))*angles(math.rad(0-2.5*math.cos(sine/3.5)),math.rad(1.5*math.cos(sine/7)),math.rad(-7.5*math.cos(sine/7))),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(30*math.cos(sine/7))+ math.sin(sine/7)/2.5,math.rad(0),math.rad(10)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(-30*math.cos(sine/7))+ -math.sin(sine/7)/2.5,math.rad(0),math.rad(-10)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-0.925-0.5*math.cos(sine/7)/2,0.5*math.cos(sine/7)/2)*angles(math.rad(-15-15*math.cos(sine/7))+ -math.sin(sine/7)/2.5,math.rad(90-10*math.cos(sine/7)),math.rad(0))*angles(math.rad(0+2.5*math.cos(sine/7)),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-1,-0.925+0.5*math.cos(sine/7)/2,-0.5*math.cos(sine/7)/2)*angles(math.rad(-15+15*math.cos(sine/7))+ math.sin(sine/7)/2.5,math.rad(-90-10*math.cos(sine/7)),math.rad(0))*angles(math.rad(0-2.5*math.cos(sine/7)),math.rad(0),math.rad(0)),0.15)
					elseif attack==false and sprint==true then
						change=1
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0,-0.1+0.1*math.cos(sine/3.5)+ -math.sin(sine/3.5)/7)*angles(math.rad(5-2.5*math.cos(sine/3.5)),math.rad(0),math.rad(10*math.cos(sine/7))),0.15)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*cf(0,0,0+0.025*math.cos(sine/3.5))*angles(math.rad(0-2.5*math.cos(sine/3.5)),math.rad(1.5*math.cos(sine/7)),math.rad(-7.5*math.cos(sine/7))),0.15)
						RW.C0=clerp(RW.C0,CFrame.new(1.5,0.5,0)*angles(math.rad(45*math.cos(sine/7))+ math.sin(sine/7)/2.5,math.rad(0),math.rad(10)),0.15)
						LW.C0=clerp(LW.C0,CFrame.new(-1.5,0.5,0)*angles(math.rad(-45*math.cos(sine/7))+ -math.sin(sine/7)/2.5,math.rad(0),math.rad(-10)),0.15)
						RH.C0=clerp(RH.C0,cf(1,-0.9-0.25*math.cos(sine/7)/2,0.5*math.cos(sine/7)/2)*angles(math.rad(-15-45*math.cos(sine/7))+ -math.sin(sine/7)/2.5,math.rad(90-10*math.cos(sine/7)),math.rad(0))*angles(math.rad(0+2.5*math.cos(sine/7)),math.rad(0),math.rad(0)),0.15)
						LH.C0=clerp(LH.C0,cf(-1,-0.9+0.25*math.cos(sine/7)/2,-0.5*math.cos(sine/7)/2)*angles(math.rad(-15+45*math.cos(sine/7))+ math.sin(sine/7)/2.5,math.rad(-90-10*math.cos(sine/7)),math.rad(0))*angles(math.rad(0-2.5*math.cos(sine/7)),math.rad(0),math.rad(0)),0.15)
					end
				elseif torvel<22 and hitfloor~=nil then
					Anim="Run"
					if attack==false then
					end
				end
			end
		end)
	end)
end
coroutine.wrap(YPNDE_fake_script)()
local function KMVVYAB_fake_script() -- ChatBypass.LocalScript 
	local script = Instance.new('LocalScript', ChatBypass)

	script.Parent.MouseButton1Click:Connect(function()
		loadstring(game:HttpGet("https://the-shed.xyz/roblox/scripts/ChatBypass", true))()
	end)
end
coroutine.wrap(KMVVYAB_fake_script)()
local function LLXFJJ_fake_script() -- PreviousPage.LocalScript 
	local script = Instance.new('LocalScript', PreviousPage)

	script.Parent.MouseButton1Down:Connect(function()
		script.Parent.Parent.Visible = false
	end)
end
coroutine.wrap(LLXFJJ_fake_script)()
